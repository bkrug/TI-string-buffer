       DEF  BUFALC,BUFSET,BUFGET
       DEF  BUFEDT,BUFDLT
* This library of routines stores
* strings in a way that is inspired by
* but different from the C language's
* malloc() and free() methods.
*
* Using this library you can reserve an
* area of memory of a particular size at
* a particular address with memory 
* chunks of various sizes.
*
* Each chunk contains a header pointing
* to the next chunk. The header is two
* bytes in size, and the rest stores 
* content.
*
* Among the 16 header bits,
* the first bit is set if the chunk is
* used, otherwise reset. The other 15
* are the offset to the next chunk. 
* The next chunk can be at most >7FFF
* bytes further away. Chunks are 
* expected to be sequentially located. 
* Note that if the block size is >20, 
* then the first two bytes will be 
* header bytes and only >1E bytes can 
* hold data. 

*
* The >20 bytes would have been used
* as the workspace for all STRBUF
* routines.
STRWS  BSS  >20
* holds block size
* holds address of buffer
BUFADR BSS  >2
* holds first address after the buffer
BUFEND BSS  >2

* Mask to set or reset the "used" bit.
FMASK  DATA >8000

* 
* **** BUFALC ****
* Reserve Space for string buffer
*
* R0 - buffer memory address
* R1 - buffer size (>4 to >7FFF valid)
*
* Output:
* R0 - >0000 if successful
*      >FFFF if error
*
BUFALC DATA STRWS,BUFALC+4
* Get routine parameters
       MOV  *R13,R0
       MOV  @2(13),R1
       MOV  R0,@BUFADR
* Return error if buffer size is less
* than or equal to 4
       CI   R1,4
       JLE  ALC2
* Return error if buffer size is greater
* than or equal to >8000
       MOV  R1,R1
       JLT  ALC2
* Return error if buffer size is odd.
       COC  @ONE,R1
       JEQ  ALC2	   
* Record empty chunk covering whole
* space.
ALC1   MOV  R1,*R0
* Record address of end of buffer.
	   A    R1,R0
	   MOV  R0,@BUFEND
* Report success.
       CLR  *R13
       RTWP
* Report error.
ALC2   SETO *R13
       RTWP
ONE    DATA >0001
 
* 
* **** BUFGET ****
* Copy a string from the buffer to
* another location where it can be
* manipulated.
*
* R0 - string address within buffer.
* R1 - address presumably outside the
*      buffer
* R2 - size of data to copy.
*
* The calling code is responsile for
* ensuring that there is sufficient
* space for the copy.
*
* The first byte in the destination
* will be the string length.
BUFGET DATA STRWS,BUFGET+4
       MOV  *R13,R0
       MOV  @2(13),R3
	   MOV  @4(13),R2
       BL   @CPYST
	   RTWP

* 
* **** BUFSET ****
* Put a new string in the buffer
*
* Input:
* R0 - string address outside of buffer
* R1 - size
* Output:
* R0 - contains the new string address
*    - >FFFF implies an error
BUFSET DATA STRWS,BUFSET+4
* Get routine parameters
       MOV  *R13,R0
	   MOV  @2(13),R2
* If R2 is odd, add one.
       INC  R2
       SRL  R2,1
	   SLA  R2,1
* Add 2 to space requirement due to
* header size.
	   INCT R2
* R2 now contains the required number
* of bytes.
* Find a free chunk of that size or 
* greater.
       MOV  @BUFADR,R3
SET1   MOV  *R3,R4
       CZC  @FMASK,R4
       JEQ  SET2
       SZC  @FMASK,R4
SET3   A    R4,R3
       C    R3,@BUFEND
       JL   SET1
* We passed out of the buffer.
* Report an error in caller's R0.
       SETO *R13
       RTWP
* Chunk is free, but is it large enough?
* First try to merge other free chunks.
SET2   BL   @TRYMRG
* If required space is still larger than
* the size of merged chunk, continue
* loop.
       C    R2,R4
       JH   SET3
* This chunk at R3 is large enough.
* Save a copy of its address.
       MOV  R3,R1
* Mark the chunk as used
       SOC  @FMASK,*R3
* If the chunk is large enough to split,
* do so.
* Note that it is not possible for R4-R2
* to equal 1. If the difference is not 
* zero, then there is enough space for add
* chunk header.
       S    R2,R4
       JEQ  SET4
* Decrease offset at newly filled chunk.
	   S    R4,*R3
* Record the remainder of the offset at
* next chunk.
       A    R2,R3
       MOV  R4,*R3
* R2 contains size of chunk. Decrease it
* to the size of the contents.
       DECT R2
* Copy string.
* R0 already contains the address of the
* source data.
* R1 contains the address of the 
* chunk, but don't overcopy the header.
* R2 contains size of data.
SET4   INCT R1
       MOV  R1,R3
       BL   @CPYST
* R1 now contains the address of the 
* string. Put address in caller's R0.
       MOV  R1,*R13
       RTWP
 
* 
* **** BUFEDT ****
* Replace an existing string in the
* buffer. This will involve an algorithm
* that reserves more space if the new
* string is larger than the old. It will
* move the string to a new location if
* necessary to create enough room.
*
* Input:
* R0 - current address inside of buffer
* R1 - string address outside of buffer
* R2 - size
* Output:
* R0 - contains the new string address
BUFEDT DATA EDTWS,BUFEDT+>24
EDTWS  BSS  >20
* 
* Delete the string from its old address
       MOV  *R13,R0
       BLWP @BUFDLT
* Put the string at some new address
       MOV  @2(13),R0
	   MOV  @4(13),R1
       BLWP @BUFSET
* Put the new string address in the
* caller's R13.
       MOV  R0,*R13
       RTWP
 
*
* **** BUFDLT ****
* Remove an existing string from the
* buffer and mark the space as free.
*
* Input:
* R0 - string address inside of buffer
BUFDLT DATA STRWS,BUFDLT+4
* Get routine parameters
       MOV  *R13,R3
* The block to free is located two bytes
* before the string address.
       DECT R3
* Mark the block free
       SZC  @FMASK,*R3
* Merge this newly freed chunk with 
* the following chunk if it is free.
       BL   @TRYMRG
       RTWP

*
* Try Merge Free Space
*
* Input:
* R3 - Address of a free chunk
*
* Output:
* R1 - address of end of buffer
* R3 - (unchanged)
* R4 - new size of chunk
* R5 - next full chunk
TRYMRG
* Store the address of first chunk.
       MOV  R3,R5
* Get end of buffer
       MOV  @BUFEND,R1
* Initially add 0 to R5's contents so we
* can ensure that the first chunk is
* really free.
       CLR  R4
* Each header contains an offset to the
* next block. Find the some of the
* offsets of consecutive free blocks.
TMRG1  A    R4,R5
       C    R5,R1
       JHE  TMGR2
       MOV  *R5,R4
       CZC  @FMASK,R4
       JEQ  TMRG1
* Calculate new offset
TMGR2  MOV  R5,R4
       S    R3,R4
       JEQ  TMRG3
* If new offset is greater than 0, put 
* it in header of first chunk.
       MOV  R4,*R3
TMRG3  RT

*
* Copy string
*
* Input:
* R0 - Address of source string
* R2 - Number of bytes to copy
* R3 - Address of destination string
*
* Output:
* R0 - Address after string
* R2 - (zero)
* R3 - Address after string
*
* Copy       
CPYST  MOVB *R0,*R3
       INC  R0
       INC  R3
       DEC  R2
       JNE  CPYST
       RT
       END