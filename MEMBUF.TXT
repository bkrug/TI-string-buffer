       DEF  BUFINT,BUFALC,BUFCPY,BUFREE
       DEF  BUFSRK,BUFGRW
       DEF  BLKUSE
*
       REF  STRWS,BUFADR,BUFEND
* This library of routines stores
* chunks in a way that is inspired by
* but different from the C language's
* malloc() and free() methods.
*
* Using this library you can reserve an
* area of memory of a particular size at
* a particular address with memory 
* chunks of various sizes.
*
* Each chunk contains a header pointing
* to the next chunk. The header is two
* bytes in size, and the rest stores 
* content.
*
* Among the 16 header bits,
* the first bit is set if the chunk is
* used, otherwise reset. The other 15
* are the offset to the next chunk. 
* The next chunk can be at most >7FFF
* bytes further away. Chunks are 
* expected to be sequentially located. 
* Note that if the block size is >20, 
* then the first two bytes will be 
* header bytes and only >1E bytes can 
* hold data. 

* Mask to set or reset the "used" bit.
BLKUSE DATA >8000

* 
* **** BUFINT ****
* Reserve Space for a memory buffer
*
* R0 - buffer memory address
* R1 - buffer size (>4 to >7FFF valid)
*
* Output:
* R0 - >0000 if successful
*      >FFFF if error
*
BUFINT DATA STRWS,BUFINT+4
* Get routine parameters
       MOV  *R13,R0
       MOV  @2(13),R1
       MOV  R0,@BUFADR
* Return error if buffer size is less
* than or equal to 4
       CI   R1,4
       JLE  ALC2
* Return error if buffer size is greater
* than or equal to >8000
       MOV  R1,R1
       JLT  ALC2
* Return error if buffer size is odd.
       COC  @ONE,R1
       JEQ  ALC2       
* Record empty chunk covering whole
* space.
ALC1   MOV  R1,*R0
* Record address of end of buffer.
       A    R1,R0
       MOV  R0,@BUFEND
* Report success.
       CLR  *R13
       RTWP
* Report error.
ALC2   SETO *R13
       RTWP
ONE    DATA >0001
 
* 
* **** BUFCPY ****
* Copy data between two locations.
*
* R0 - source address.
* R1 - destination address
* R2 - size of data to copy.
*
* The calling code is responsile for
* ensuring that there is sufficient
* space for the copy.
*
* The first byte in the destination
* will be the data length.
BUFCPY DATA STRWS,BUFCPY+4
       MOV  *R13,R0
       MOV  @2(13),R1
       MOV  @4(13),R2
* If data length is 0, return
       MOV  R2,R2
       JEQ  CPYRT
* Let R2 = end of source range
       A    R0,R2
* Check if source and destination
* overlap.
       C    R0,R1
       JH   CPYST
       C    R2,R1
       JL   CPYST
* Let R1 = end of destination range
       A    @4(13),R1
* Copy from end to start
CPY1   DEC  R1
       DEC  R2
       MOVB *R2,*R1
       C    R2,R0
       JH   CPY1
       RTWP
* Copy from start to end
CPYST  MOVB *R0+,*R1+
       C    R0,R2
       JL   CPYST
CPYRT  RTWP

* 
* **** BUFALC ****
* Reserve space in the buffer
*
* Input:
* R0 - size
* Output:
* R0 - the new address of assigned space
*    - >FFFF implies an error
BUFALC DATA STRWS,BUFALC+4
* Get routine parameters
       MOV  *R13,R0
* Round R0 up to an even number.
       INC  R0
       SRL  R0,1
       SLA  R0,1
* Add 2 to space requirement due to
* header size.
       INCT R0
* R0 now contains the required number
* of bytes.
* Find a free chunk of that size or 
* greater.
       MOV  @BUFADR,R3
SET1   MOV  *R3,R4
       CZC  @BLKUSE,R4
       JEQ  SET2
       SZC  @BLKUSE,R4
SET3   A    R4,R3
       C    R3,@BUFEND
       JL   SET1
* We passed out of the buffer.
* Report an error in caller's R0.
       SETO *R13
       RTWP
* Chunk is free, but is it large enough?
* First try to merge other free chunks.
SET2   BL   @TRYMRG
* If required space is still larger than
* the size of merged chunk, continue
* loop.
       C    R0,R4
       JH   SET3
* This chunk at R3 is large enough.
* Save a copy of its address.
       MOV  R3,R1
* Mark the chunk as used
       SOC  @BLKUSE,*R3
* If the chunk is large enough to split,
* do so.
* Note that it is not possible for R4-R0
* to equal 1. If the difference is not 
* zero, then there is enough space to add
* a chunk header.
       S    R0,R4
       JEQ  SET4
* Decrease offset at newly filled chunk.
       S    R4,*R3
* Record the remainder of the offset at
* next chunk.
       A    R0,R3
       MOV  R4,*R3
* R1 contains the address of the 
* chunk. Change it to address of chunk
* contents.
SET4   INCT R1
* R1 now contains the address of the 
* string. Put address in caller's R0.
       MOV  R1,*R13
       RTWP
 
*
* **** BUFREE ****
* Remove an existing chunk from the
* buffer and mark the space as free.
*
* Input:
* R0 - string address inside of buffer
BUFREE DATA STRWS,BUFREE+4
* Get routine parameters
       MOV  *R13,R3
* The block to free is located two bytes
* before the string address.
       DECT R3
* Mark the block free
       SZC  @BLKUSE,*R3
* Merge this newly freed chunk with 
* the following chunk if it is free.
       BL   @TRYMRG
       RTWP

*
* Try Merge Free Space
*
* Input:
* R3 - Address of a free chunk
*
* Output:
* R1 - address of end of buffer
* R3 - (unchanged)
* R4 - new size of chunk
* R5 - next full chunk
TRYMRG
* Store the address of first chunk.
       MOV  R3,R5
* Get end of buffer
       MOV  @BUFEND,R1
* Initially add 0 to R5's contents so we
* can ensure that the first chunk is
* really free.
       CLR  R4
* Each header contains an offset to the
* next block. Find the some of the
* offsets of consecutive free blocks.
TMRG1  A    R4,R5
       C    R5,R1
       JHE  TMGR2
       MOV  *R5,R4
       CZC  @BLKUSE,R4
       JEQ  TMRG1
* Calculate new offset
TMGR2  MOV  R5,R4
       S    R3,R4
       JEQ  TMRG3
* If new offset is greater than 0, put 
* it in header of first chunk.
       MOV  R4,*R3
TMRG3  RT

*
* Shrink allocation.
* Reduce allocation of space
* if necessary
*
* Input:
* R0 - address inside of buffer
* R1 - maximum acceptable size
BUFSRK DATA STRWS,BUFSRK+4
* Let R8 = address of block
* Let R9 = max size + 2
       MOV  *R13,R8
       DECT R8
       MOV  @2(13),R9
       INCT R9
* Let R10 = current block size
       MOV  *R8,R10
       SZC  @BLKUSE,R10
* Check if too big
       C    R10,R9
       JLE  LESRT
* Mark block header with less space
* Let R10 = spare space
       S    R9,R10
       SOC  @BLKUSE,R9
       MOV  R9,*R8
* Create a new empty block header
       SZC  @BLKUSE,R9
       A    R9,R8
       MOV  R10,*R8
* Merge new free block with later free
* blocks.
       MOV  R8,R3
       BL   @TRYMRG
*
LESRT  RTWP

*
* Grow allocation if necessary.
*
* Input:
* R0 - address of block
* R1 - required size
BUFGRW DATA STRWS,BUFGRW+4
* Let R8 = address of block
* Let R9 = required size + 2
       MOV  *R13,R8
       DECT R8
       MOV  @2(13),R9
       INCT R9
* Let R10 = current block size
       MOV  *R8,R10
       SZC  @BLKUSE,R10
* Check if already big enough      
       C    R10,R9
	   JHE  GRWRT
* Let R9 = twice the desired size + 2
       SLA  R9,1
       DECT R9
* Let R11 = address of next block
       MOV  R8,R11
	   A    R10,R11
* Confirm that next block is free
       MOV  *R11,R12
       COC  @BLKUSE,R12
	   JEQ  GRWRT
* Let R12 = total size of both blocks
	   A    R10,R12
* Confirm that total size is big enough
       C    R12,R9
	   JL   GRWRT
* Grow the original block
       MOV  R9,*R8
	   SOC  @BLKUSE,*R8
* Let R12 = new size of free block
       S    R9,R12
* If we used all the free space, return
       JEQ  GRWRT
* Let R8 = address of new free block
       A    R9,R8
* Create new free block
       MOV  R12,*R8
*
GRWRT  RTWP

       END