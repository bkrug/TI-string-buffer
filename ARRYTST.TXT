       DEF  TSTLST,RSLTFL
*
       REF  AEQ,ABLCK,AL
*
       REF  ARYALC,ARYADD,ARYINS,ARYDEL
       REF  ARYADR
*
       REF  BUFADR,BUFEND

TSTLST DATA TSTEND-TSTLST-2/8
* Allocate array with 2-byte elements
       DATA ALC1
       TEXT 'ALC1  '
* Allocate array with 8-byte elements
       DATA ALC2
       TEXT 'ALC2  '
* There is not enough space to allocate
* this array.
       DATA ALC3
       TEXT 'ALC3  '
* Add element to empty array
       DATA ADD1
       TEXT 'ADD1  '
* Add element to 2-byte elem array
       DATA ADD2
       TEXT 'ADD2  '
* Add element to 4-byte elem array
       DATA ADD3
       TEXT 'ADD3  '
* Add element, mem-block grows
*    without moving
       DATA ADD4
       TEXT 'ADD4  '
* Add element, mem-block grows
*    without moving
       DATA ADD5
       TEXT 'ADD5  '
* Add element, mem-block grows and moves
TSTEND
RSLTFL BYTE RSLTFE-RSLTFL-1
       TEXT 'DSK2.TESTRESULT.TXT'
RSLTFE
       EVEN

*
* Allocate array with 2-byte elements
ALC1
* Arrange
       LI   R0,ALC1Y
       MOV  R0,@BUFADR
       LI   R0,ALC1Z
       MOV  R0,@BUFEND
* Act
* Store result address in R10
* (2^1 = 2)
       LI   R0,1
       BLWP @ARYALC
       MOV  R0,R10
* Assert
       LI   R0,ALC1Y+>12
       MOV  R10,R1
       BLWP @AEQ
       TEXT 'R0 should return the address at which '
       TEXT 'the array was assigned to. '
       TEXT 'This the first free address in the buffer.'
       BYTE 0
       EVEN
*
       LI   R0,ALC1A
       MOV  R10,R1
       LI   R2,ALC1B-ALC1A
       BLWP @ABLCK
       TEXT 'First word should specify 0 elements '
       TEXT 'exist in the array. '
       TEXT 'Second word should specify element '
       TEXT 'length using "1" for 2 bytes. '
       TEXT '(2^1 = 2)'
       BYTE 0
       EVEN
*
       RT
* Expected array contents.
ALC1A  DATA >0000,>0001
ALC1B
* Initial buffer space
ALC1Y  DATA >8010
       BSS  >0E
       DATA >0020
       BSS  >1E
       DATA >8010
       BSS  >0E
ALC1Z

*
* Allocate array with 8-byte elements
ALC2
* Arrange
       LI   R0,ALC2Y
       MOV  R0,@BUFADR
       LI   R0,ALC2Z
       MOV  R0,@BUFEND
* Act
* Store result address in R10
* (2^3 = 8)
       LI   R0,3
       BLWP @ARYALC
       MOV  R0,R10
* Assert
       LI   R0,ALC2Y+2
       MOV  R10,R1
       BLWP @AEQ
       TEXT 'R0 should return the address at which '
       TEXT 'the array was assigned to. '
       TEXT 'This the first free address in the buffer.'
       BYTE 0
       EVEN
*
       LI   R0,ALC2A
       MOV  R10,R1
       LI   R2,ALC2B-ALC2A
       BLWP @ABLCK
       TEXT 'First word should specify 0 elements '
       TEXT 'exist in the array. '
       TEXT 'Second word should specify element '
       TEXT 'length using "3" for 8 bytes. '
       TEXT '(2^3 = 8)'
       BYTE 0
       EVEN
*
       RT
* Expected array contents.
ALC2A  DATA >0000,>0003
ALC2B
* Initial buffer space
ALC2Y  DATA >0040
       BSS  >3E
ALC2Z

*
* Fail to allocate an array.
* No space.
ALC3
* Arrange
       LI   R0,ALC3Y
       MOV  R0,@BUFADR
       LI   R0,ALC3Z
       MOV  R0,@BUFEND
* Act
       LI   R0,5
       BLWP @ARYALC
* Assert
       MOV  R0,R1
       LI   R0,>FFFF
       BLWP @AEQ
       TEXT 'The array should not have been loaded.'
       BYTE 0
       EVEN
*
       RT
* Initial buffer space
ALC3Y  DATA >8040
       BSS  >3E
ALC3Z

*
* Add an element to an empty array
ADD1
* Arrange
       LI   R0,ADD1Y
       MOV  R0,@BUFADR
       LI   R0,ADD1Z
       MOV  R0,@BUFEND
* Act
       LI   R0,ADD1X+2
       BLWP @ARYADD
       MOV  R0,R9
       MOV  R1,R10
* Assert
       LI   R0,ADD1X+2
       MOV  R9,R1
       BLWP @AEQ
       TEXT 'Array should not have moved.'
       BYTE 0
       EVEN
*
       LI   R0,>0001
       MOV  *R9,R1
       BLWP @AEQ
       TEXT 'Array should now have one element.'
       BYTE 0
       EVEN
*
       LI   R0,>8028
       MOV  @ADD1X,R1
       BLWP @AEQ
       TEXT 'Memory block should not grown.'
       BYTE 0
       EVEN
*
       LI   R0,ADD1X+6
       MOV  R10,R1
       BLWP @AEQ
       TEXT 'New element is first in the array. '
       TEXT 'Its address should be right after '
       TEXT 'the array header, which is 4-bytes long.'
       BYTE 0
       EVEN
*
       RT
* Initial buffer space
ADD1Y  DATA >8008
       BSS  >06
ADD1X  
* Array's block header
       DATA >8028
* Array header
       DATA >0000,>0003
       BSS  >1A
       DATA >0010
       BSS  >16
ADD1Z

*
* Add an element to an array with
* 2-byte elements.
ADD2
* Arrange
       LI   R0,ADD2Y
       MOV  R0,@BUFADR
       LI   R0,ADD2Z
       MOV  R0,@BUFEND
* Act
       LI   R0,ADD2Y+2
       BLWP @ARYADD
       MOV  R0,R9
       MOV  R1,R10
* Assert
       LI   R0,ADD2Y+2
       MOV  R9,R1
       BLWP @AEQ
       TEXT 'Array should not have moved.'
       BYTE 0
       EVEN
*
       LI   R0,>8020
       MOV  @ADD2Y,R1
       BLWP @AEQ
       TEXT 'Memory block should not grown.'
       BYTE 0
       EVEN
*
       LI   R0,ADD2Y+2+4+6
       MOV  R10,R1
       BLWP @AEQ
       TEXT 'Array should have four elements '
       TEXT 'but the contents of the new element '
       TEXT 'are non-deterministic.'
       BYTE 0
       EVEN
*
       RT
* Expected array contents.
* Basically only the element count
* should change.
* We don't care about the inital
* contents of the new element.
ADD2A
       DATA >0004,>0001
       DATA >0101,>0202,>0303
ADD2B
* Initial buffer space
ADD2Y  
* Array's block header
       DATA >8020
* Array header
       DATA >0003,>0001
* The 3 elements in the array
       DATA >0101,>0202,>0303
       BSS  >14
       DATA >0010
       BSS  >E
ADD2Z

*
* Add an element to an array with
* 4-byte elements.
ADD3
* Arrange
       LI   R0,ADD3Y
       MOV  R0,@BUFADR
       LI   R0,ADD3Z
       MOV  R0,@BUFEND
* Act
       LI   R0,ADD3X+2
       BLWP @ARYADD
       MOV  R0,R9
       MOV  R1,R10       
* Assert
       LI   R0,ADD3X+2
       MOV  R9,R1
       BLWP @AEQ
       TEXT 'Array should not have moved.'
       BYTE 0
       EVEN
*
       LI   R0,ADD3X+2+4+8
       MOV  R10,R1
       BLWP @AEQ
       TEXT 'Location of new element should '
       TEXT 'follow last previous element.'
       BYTE 0
       EVEN
*
       LI   R0,>8020
       MOV  @ADD3X,R1
       BLWP @AEQ
       TEXT 'Memory block should not grown.'
       BYTE 0
       EVEN
*
       LI   R0,ADD3A
       LI   R1,ADD3X+2
       LI   R2,>0C
       BLWP @ABLCK
       TEXT 'Array should now have three '
       TEXT 'elements, and the first two '
       TEXT 'elements should not change.'
       BYTE 0
       EVEN
*
       RT
* Expected array contents after adding
* an element.
ADD3A  DATA >0003,>0002
       DATA >3003,>0330,>2002,>0220
ADD3B
* Initial buffer contents
ADD3Y  DATA >0004
       BSS  >2
ADD3X  DATA >8020
* Array header
       DATA >0002,>0002
* Array contents
       DATA >3003,>0330,>2002,>0220
* Unused contents of the same block
       BSS  >12
*
       DATA >0010
ADD3Z

*
* Add an element. Grow the memory block.
ADD4
* Arrange
       LI   R0,ADD4Y
       MOV  R0,@BUFADR
       LI   R0,ADD4Z
       MOV  R0,@BUFEND
* Act
       LI   R0,ADD4X+2
       BLWP @ARYADD
       MOV  R0,R9
       MOV  R1,R10 
* Assert
       LI   R0,ADD4X+2
       MOV  R9,R1
       BLWP @AEQ
       TEXT 'Array should not have moved.'
       BYTE 0
       EVEN
*
       LI   R0,ADD4X+2+4+24
       MOV  R10,R1
       BLWP @AEQ
       TEXT 'Location of new element should '
       TEXT 'follow last previous element.'
       BYTE 0
       EVEN
*
       LI   R0,>8000+ADD4W-ADD4X
       MOV  @ADD4X,R1
       BLWP @AL
       TEXT 'Memory block should have grown.'
       BYTE 0
       EVEN
*
       LI   R0,ADD4A
       LI   R1,ADD4X+2
       LI   R2,ADD4B-ADD4A
       BLWP @ABLCK
       TEXT 'Array should now have four '
       TEXT 'elements, and the first three '
       TEXT 'elements should not change.'
       BYTE 0
       EVEN
*
       RT
* Expected array contents after adding
*    an element
ADD4A  DATA >0004,>0003
       DATA >1111,>0101,>1001,>0110
       DATA >2222,>0202,>2002,>0220
       DATA >3333,>0303,>3003,>0330
ADD4B
* Initial buffer contents
ADD4Y  DATA >0010
       BSS  >0E
ADD4X  DATA >8000+ADD4W-ADD4X
       DATA >0003,>0003
       DATA >1111,>0101,>1001,>0110
       DATA >2222,>0202,>2002,>0220
       DATA >3333,>0303,>3003,>0330
       BSS  >4
ADD4W  DATA >0040
       BSS  >3E
ADD4Z

*
* Add an element. Grow the memory block.
ADD5
* Arrange
       LI   R0,ADD5Y
       MOV  R0,@BUFADR
       LI   R0,ADD5Z
       MOV  R0,@BUFEND
* Act
       LI   R0,ADD5X+2
       BLWP @ARYADD
       MOV  R0,R9
       MOV  R1,R10 
* Assert
       LI   R0,ADD5X+2
       MOV  R9,R1
       BLWP @AEQ
       TEXT 'Array should not have moved.'
       BYTE 0
       EVEN
*
       LI   R0,ADD5X+2+4+10
       MOV  R10,R1
       BLWP @AEQ
       TEXT 'Location of new element should '
       TEXT 'follow last previous element.'
       BYTE 0
       EVEN
*
       LI   R0,>8000+ADD5W-ADD5X
       MOV  @ADD5X,R1
       BLWP @AL
       TEXT 'Memory block should have grown.'
       BYTE 0
       EVEN
*
       LI   R0,ADD4A
       LI   R1,ADD4X+2
       LI   R2,ADD4B-ADD4A
       BLWP @ABLCK
       TEXT 'Array should now have four '
       TEXT 'elements, and the first three '
       TEXT 'elements should not change.'
       BYTE 0
       EVEN
*
       RT
* Expected array contents after adding
*    an element
ADD5A
       DATA >0006,>0001
       DATA >1111,>2222,>3333,>4444
       DATA >5555
ADD5B
* Initial buffer contents
ADD5Y  DATA >0008
       BSS  >06
	   DATA >8008
	   BSS  >06
ADD5X  DATA >8000+ADD4W-ADD4X
* Array header
       DATA >0005,>0001
* Array elements (2-bytes each)
       DATA >1111,>2222,>3333,>4444
       DATA >5555
ADD5W  DATA >0020
       BSS  >1E
	   DATA >8010
	   BSS  >1E
ADD5Z

       END