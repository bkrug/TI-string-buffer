       DEF  STRALC,STRGET,STRSET
       DEF  STREDT,STRDLT
*
*
* R8 holds block size
* R9 holds address of block list
* R10 holds address of buffer
STRWS  BSS  >20
 
* Block list:
* First 8 bytes are the root node size
* list.
* The rest represent the nodes.
 
*
* Reserve Space for string buffer
*
* R0 - buffer memory address
* R1 - buffer size
* R2 - block size
*
* R1 only specifies the amount of memory
*   used to store the strings themselves
* Additional memory is used to track
*   free space.
* Total memory use will be:
*   buffer size +
*   8 +
*   (buffer size / block size / 2 + 8)
*
STRALC DATA STRWS,STRALC+4
* Get routine parameters
       MOV  @0(13),R10
       MOV  @2(13),R2
       MOV  @4(13),R8
* Calc location of free space storeage
       MOV  R2,R9
       A    R10,R9
*
* * Build the Root Node Size List *
*
* Calculate number of blocks in buffer
       CLR  R1
       DIV  R8,R1
* R1 now contains the number of blocks
* in the buffer.
* R2 will store the blocks not yet
* marked as free.
       MOV  R1,R2
       MOV  R1,R4
* Fill the first size list with -1
       MOV  R9,R3
       SETO *R3+
       SETO *R3+
       SETO *R3+
       SETO *R3+
* R3 will store the current position in
* root node list.
       MOV  R9,R3
* Find power of 2 for R1's value.
STRA0  BL   @PWR2DW
* R0 now contains the power of 2
* representing the number of blocks in
* the first clump of free blocks.
* Raise 2 to the power of value in R0,
* and place it in R1.
       LI   R1,1
       SLA  R1,0
* Store size of the clump in the first
* byte of the free list.
       SLA  R0,8
       MOVB R0,*R3
* Subtract the number of blocks from
* the list of blocks that we have yet
* to record.
       S    R1,R2
* Move to the next byte of free space
* list.
       INC  R3
* If there are blocks not yet recorded
* as free, then do the process over.
       MOV  R2,R1
       JNE  STRA0
*
* * Build Node List *
*
* R3 will store the current position in
* node list
       MOV  R9,R3
       AI   R3,>8
* R4 still contains the number of blocks
* in the buffer.
* Divide by 2 and add >8 to determine
* number of bytes in node list
       SRL  R4,1
       AI   R4,>8
* Find end of node list
       A    R3,R4
* Mark every node not full, not split.
STRA3  CLR  *R3+
       C    R3,R4
       JL   STRA3
       RTWP
 
*
* Copy a string from the buffer to
* another location where it can be
* manipulated.
*
* R0 - string address within buffer.
* R1 - address presumably outside the
*      buffer
*
* The calling code is responsile for
* ensuring that there is sufficient
* space for the copy.
*
* The first byte in the destination
* will be the string length.
STRGET DATA STRWS,STRSET+4
       RTWP
 
*
* Put a new string in the buffer
*
* Input:
* R0 - string address outside of buffer
* Output:
* R0 - contains the new string address
STRSET DATA STRWS,STRSET+4
* Store original string address in R2
        MOV  @0(13),R2
* First determine the power of 2 for 
*    the required space.
* Use the number of characters in the
*    string plus one.
        MOVB *R2,R1
		INC  R1
		BL   @PWR2UP
* R0 now contains the exponent for the
*    needed space as a power of two.
        
* When arriving at a node:
*    If the node is full, go up a level.
*    If the node is the desired size,
*       use the node and mark it full.
*    If the node is not split, split it
*       and go down to the right-hand
*       sub-node.
*    If the node is split and we have
*       not been down the right-hand
*       side, go to the right-hand sub-
*       node.
*    If the node is split and we have
*       been down the right-hand side,
*       go to the left-hand sub-node.
*    Don't go to a lower node than exists.
*    Don't go above the root node.
       RTWP
 
*
* Replace an existing string in the
* buffer. This will involve an algorithm
* that reserves more space if the new
* string is larger than the old. It will
* move the string to a new location if
* necessary to create enough room.
*
* Input:
* R0 - string address outside of buffer
* R1 - current address inside of buffer
* Output:
* R0 - contains the new string address
STREDT DATA STRWS,STREDT+4
       RTWP
 
*
* Remove an existing string from the
* buffer and mark the space as free.
*
* Input:
* R0 - string address inside of buffer
STRDLT DATA STRWS,STRDLT+4
       RTWP

*
* Get status of a node
* Input:
* R0 index of tree
* R1 node depth - root is 0 (must be 0-15)
* R2 represents how far right node is
* Output:
* R3 all bits on if node is split.
* R4 all bits on if node is full.
NDSTS  
* As Proof of concept assume that there 
* is only one tree. (ignore R0)
       MOV  R9,R5
	   AI   R5,8
* If node depth is zero, nodes of proper
* depth start at R9+8 
	   MOV  R1,R1
	   JEQ  NDSTS1
* If node depth is one, nodes of proper
* depth start at R9+9
	   INC  R5
	   CI   R1,1
	   JEQ  NDSTS1
* Otherwise nodes of this depth start at
* address R9 + 8 + 1 + 2^(R1-2).
* R9 holds the address of the block list.
* and the first 8 bytes are the tree
* size.
       DECT R1
	   MOV  R1,R0
       LI   R1,1
	   SLA  R1,0
       A    R1,R5
* R5 now contains the address where the
* nodes of the correct depth first start
NDSTS1 MOV  R2,R1
       SRL  R1,2
	   A    R1,R5
* R5 now contains the address in which
* we can find data for four nodes,
* one of them being our target node.
       SLA  R1,2
       S    R1,R2
	   SLA  R2,1
* R2 now contains either 0,2,4, or 8
* depending on whether our target node 
* is the 1st, 2nd, 3rd, or 4th bit pair
* at address in R5.
*
* Next move those four bit pairs to R5.
	   MOVB *R5,R5
* Find out if node is split.
       CLR  R3
       LI   R0,SPTMSK
       A    R2,R0
	   COC  *R0,R5
	   JNE  NDSTS2
	   SETO R3
* Find out if node is full.
NDSTS2 CLR  R4
	   LI   R0,FLLMSK
       A    R2,R0
	   COC  *R0,R5
	   JNE  NDSTS3
	   SETO R4
NDSTS3
       RT

* Ones masks for detecting split nodes.
SPTMSK DATA >8000,>2000,>0800,>0200
* Ones masks for detecting full nodes.
FLLMSK DATA >4000,>1000,>0400,>0100
	   
*
* Find the power of 2 rounded down
* Input R1: contains value to find 
*           power for.
* Output R0: contains power
*
PWR2DW CLR  R0
PWRA   SRL  R1,1
       MOV  R1,R1
       JEQ  PWRB
       INC  R0
       JMP  PWRA 
PWRB   RT

*
* Find the power of 2 rounded up
* Input R1: contains value to find 
*           power for.
* Output R0: contains power
PWR2UP CLR  R0
       MOV  R1,R1
	   JEQ  PWRD
       DEC  R1
PWRC   SRL  R1,1
       INC  R0
       MOV  R1,R1	   
       JNE  PWRC
PWRD   RT
       END