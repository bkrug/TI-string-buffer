       DEF  STRALC,STRGET,STRSET
       DEF  STREDT,STRDLT
* This was an attempt to implement a
* way to store strings of text in a 
* buffer using a buddy memory algorithm.
* It was an okay idea, but that
* algorithm is really meant for 
* operating systems, not individual
* programs. An implementation of C's
* malloc() and free() may be better
* advised.
*
* https://en.wikipedia.org/wiki/Buddy_memory_allocation
* The wikipedia article explains the
* idea of the algorithm.
*
* Had I completed this code, the idea
* would have been to have an area of
* memory containing space for strings
* followed by an area containing inform-
* ation about which areas are still open
* or filled.
*
* Example:
* Below is an example of a buffer and
* how memory would be used in that
* example.
*
* A very small buffer would only be >300
* bytes with block sizes of >10 bytes.
* One or more block is a chunk of 
* memory. Pairs of chunks can be 
* combined into a larger chunk if done
* so in accord with the Buddy Memory 
* Algorithm. The largest possible chunk
* is the root trunk in a tree.
*
* In this example a >300 byte space
* could would hold two trees. The 
* leftmost tree (or the tree at lower
* memory addresses) would be >200 bytes
* long. The rightmost tree would be >100
* bytes long. It is not possible to have
* one tree because >10*2^x cannot result
* in the number >300 regardless of the
* value of x.
*
* In this example the memory structure 
* would be:
* BYTES  DESCRIPTION
* >0300  String buffer
* >0008  Contains Depth of each tree.
* >0011  Split/Full data for first tree
* >0009  Split/Full data for second tree
*
* The string buffer is divided into 
* various subsections containing strings
* and each subsection has a length that
* could be described >10*2^x where x is
* an integer.
*
* The area containing the depth of each
* tree would contain >05, >04, and the
* other six bytes would each contain 
* >FF. The first tree has a root chunk
* of >10*2^5 which equals >200. The
* second tree has a root chunk of 
* >10*2^4 which equals >100 bytes. Two
* trees are sufficient to cover all of
* the >300 bytes space, so all of the
* other six bytes contain >FF.
*
* The data on the first tree tells the
* system which chunks in the tree are
* split and which are full. Each chunk
* requres two bits to represent this
* data. The first byte in this area of
* memory contains a bit that is set if
* the root chunk is split. The second
* bit is set if the roo chunk is full.
* The other six bits in that byte are
* ignored. The second byte represents
* the two chunks that are half the size
* of the root (>100 bytes each). Four
* bits tell us if they are split and/or
* full. Four are ignored. The third
* byte represents chunks one level 
* deeper and all eight bits represent
* four chunks (>80 bytes). The forth
* and fifth byte represent chunks that
* are >40 bytes each). 6th to 9th bytes
* are the next level deeper, and the 
* last eight bytes represent the
* smallest possible chunks of memory.
* The split-bit is always reset, but
* the full bit might be set or reset.
*
* The data on the second tree tells
* the system the same information, but
* represents a smaller tree.

*
* The >20 bytes would have been used
* as the workspace for all STRBUF
* routines.
* R9 holds address of block list
STRWS  BSS  >20
* holds block size
BLOCKZ BSS  >2
* holds address of buffer
BUFADR BSS  >2
 
*
* Reserve Space for string buffer
*
* R0 - buffer memory address
* R1 - buffer size
* R2 - block size
*
* R1 only specifies the amount of memory
*   used to store the strings themselves
* Additional memory is used to track
*   free space.
* Total memory use will be:
*   buffer size +
*   8 +
*   (buffer size / block size / 2 + 8)
*
STRALC DATA STRWS,STRALC+4
* Get routine parameters
       MOV  @0(13),@BUFADR
       MOV  @2(13),R2
       MOV  @4(13),@BLOCKZ
* Calc location of free space storeage
       MOV  R2,R9
       A    @BUFADR,R9
*
* * Build the Root Node Size List *
*
* Calculate number of blocks in buffer
       CLR  R1
       DIV  @BLOCKZ,R1
* R1 now contains the number of blocks
* in the buffer.
* R2 will store the blocks not yet
* marked as free.
       MOV  R1,R2
       MOV  R1,R4
* Fill the first size list with -1
       MOV  R9,R3
       SETO *R3+
       SETO *R3+
       SETO *R3+
       SETO *R3+
* R3 will store the current position in
* root node list.
       MOV  R9,R3
* Find power of 2 for R1's value.
STRA0  BL   @PWR2DW
* R0 now contains the power of 2
* representing the number of blocks in
* the first clump of free blocks.
* Raise 2 to the power of value in R0,
* and place it in R1.
       LI   R1,1
       SLA  R1,0
* Store size of the clump in the first
* byte of the free list.
       SLA  R0,8
       MOVB R0,*R3
* Subtract the number of blocks from
* the list of blocks that we have yet
* to record.
       S    R1,R2
* Move to the next byte of free space
* list.
       INC  R3
* If there are blocks not yet recorded
* as free, then do the process over.
       MOV  R2,R1
       JNE  STRA0
*
* * Build Node List *
*
* R3 will store the current position in
* node list
       MOV  R9,R3
       AI   R3,>8
* R4 still contains the number of blocks
* in the buffer.
* Divide by 2 and add >8 to determine
* number of bytes in node list
       SRL  R4,1
       AI   R4,>8
* Find end of node list
       A    R3,R4
* Mark every node not full, not split.
STRA3  CLR  *R3+
       C    R3,R4
       JL   STRA3
       RTWP
 
*
* Copy a string from the buffer to
* another location where it can be
* manipulated.
*
* R0 - string address within buffer.
* R1 - address presumably outside the
*      buffer
*
* The calling code is responsile for
* ensuring that there is sufficient
* space for the copy.
*
* The first byte in the destination
* will be the string length.
STRGET DATA STRWS,STRSET+4
       RTWP
 
*
* Put a new string in the buffer
*
* Input:
* R0 - string address outside of buffer
* Output:
* R0 - contains the new string address
STRSET DATA STRWS,STRSET+4
* Store original string address in R2
        MOV  @0(13),R2
* First determine the power of 2 for 
*    the required number of blocks.
* Use the number of characters in the
*    string plus one.
* Divide that number by the block size
*    rounding up.
        CLR  R0
        MOVB *R2,R1
		SRL  R1,8
		INC  R1
		DIV  @BLOCKZ,R0
		MOV  R1,R1
		JEQ  SSET1
		INC  R0
SSET1   MOV  R0,R1
		BL   @PWR2UP
* R0 now contains the exponent for the
*    needed space as a power of two.
* Store it in R3.
		MOV  R0,R3
* Convert it to the tree depth
        MOV  R9,R12
		AI   R12,8
		MOVB R12,*R12
		SRL  R12,8
		S    R3,R12
* R12 now contains the target depth
*    for the string.
* Initialize tree search
        CLR  R1
		CLR  R2
* When arriving at a node:
*    If the node is full, go up a level.
*    If the node is the desired size,
*       use the node and mark it full.
*    If the node is not split, split it
*       and go down to the right-hand
*       sub-node.
*    If the node is split and we have
*       not been down the right-hand
*       side, go to the right-hand sub-
*       node.
*    If the node is split and we have
*       been down the right-hand side,
*       go to the left-hand sub-node.
*    Don't go to a lower node than exists.
*    Don't go above the root node.
SSETS  BL   @NDSTS
*    If the node is full, go up a level.
	   MOV  R4,R4
	   JNE  SSETUP
*    If the node is the desired size,
*       use the node and mark it full.
       MOV  R3,R3
	   JNE  SSETS2
       	   
SSETS2
* Move up a level	  
SSETUP
       RTWP
 
*
* Replace an existing string in the
* buffer. This will involve an algorithm
* that reserves more space if the new
* string is larger than the old. It will
* move the string to a new location if
* necessary to create enough room.
*
* Input:
* R0 - string address outside of buffer
* R1 - current address inside of buffer
* Output:
* R0 - contains the new string address
STREDT DATA STRWS,STREDT+4
       RTWP
 
*
* Remove an existing string from the
* buffer and mark the space as free.
*
* Input:
* R0 - string address inside of buffer
STRDLT DATA STRWS,STRDLT+4
       RTWP

*
* Get status of a node
*
* Input:
* R0 index of tree
* R1 node depth - root is 0 (must be 0-15)
* R2 represents how far right node is
* Output:
* R3 all bits on if node is split.
* R4 all bits on if node is full.
NDSTS  
* As Proof of concept assume that there 
* is only one tree. (ignore R0)
       MOV  R9,R5
	   AI   R5,8
* If node depth is zero, nodes of proper
* depth start at R9+8 
	   MOV  R1,R1
	   JEQ  NDSTS1
* If node depth is one, nodes of proper
* depth start at R9+9
	   INC  R5
	   CI   R1,1
	   JEQ  NDSTS1
* Otherwise nodes of this depth start at
* address R9 + 8 + 1 + 2^(R1-2).
* R9 holds the address of the block list.
* and the first 8 bytes are the tree
* size.
       MOV  R1,R0
       DECT R0
       LI   R6,1
	   SLA  R6,0
       A    R6,R5
* R5 now contains the address where the
* nodes of the correct depth first start
NDSTS1 MOV  R2,R6
       SRL  R6,2
	   A    R6,R5
* R5 now contains the address in which
* we can find data for four nodes,
* one of them being our target node.
       SLA  R6,2
       NEG  R6
       A    R2,R6
	   SLA  R6,1
* R6 now contains either 0,2,4, or 8
* depending on whether our target node 
* is the 1st, 2nd, 3rd, or 4th bit pair
* at address in R5.
*
* Next move those four bit pairs to R5.
	   MOVB *R5,R5
* Find out if node is split.
       CLR  R3
       LI   R0,SPTMSK
       A    R6,R0
	   COC  *R0,R5
	   JNE  NDSTS2
	   SETO R3
* Find out if node is full.
NDSTS2 CLR  R4
	   LI   R0,FLLMSK
       A    R6,R0
	   COC  *R0,R5
	   JNE  NDSTS3
	   SETO R4
NDSTS3
       RT

* Ones masks for detecting split nodes.
SPTMSK DATA >8000,>2000,>0800,>0200
* Ones masks for detecting full nodes.
FLLMSK DATA >4000,>1000,>0400,>0100
	   
*
* Find the power of 2 rounded down
* Input R1: contains value to find 
*           power for.
* Output R0: contains power
*
PWR2DW CLR  R0
PWRA   SRL  R1,1
       MOV  R1,R1
       JEQ  PWRB
       INC  R0
       JMP  PWRA 
PWRB   RT

*
* Find the power of 2 rounded up
* Input R1: contains value to find 
*           power for.
* Output R0: contains power
PWR2UP CLR  R0
       MOV  R1,R1
	   JEQ  PWRD
       DEC  R1
PWRC   SRL  R1,1
       INC  R0
       MOV  R1,R1	   
       JNE  PWRC
PWRD   RT
       END