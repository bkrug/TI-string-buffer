       DEF  STRALC,STRGET,STRSET
       DEF  STREDT,STRDLT
* This library of routines stores
* strings in a way that is inspired by
* but different from the C language's
* malloc() and free() methods.
*
* Using this library you can reserve an
* area of memory of a particular size at
* a particular address with a particular
* minimum block size.
*
* A string stored in the buffer you
* define is up to 256 bytes long. The
* first byte represents the number of
* characters in the string. The rest of
* the string is the contents of the
* string.
*
* Terms:
* Block - measured in bytes. The 
*    smallest number of bytes that can
*    be allocated. When you allocated a
*    buffer, you specify the block size.
* Chunk - A collection of one or more
*    blocks within the buffer.
*
* Each chunk starts with 16 header bits.
* The first bit is set if the chunk is
* used, otherwise reset. The other 15
* are the offset to the next chunk. 
* The next chunk can be at most >8000
* bytes further away. Chunks are 
* expected to be sequentially located. 
* Note that if the block size is >20, 
* then the first two bytes will be 
* header bytes and only >1E bytes can 
* hold data. If a chunk is two blocks 
* long, it can hold >3E bytes of data.
*
* The first two bytes of the buffer hold
* the address of the first byte 
* following the buffer. Every byte after
* that is part of a Chunk. The buffer
* must not be larger than >8000 bytes.

*
* The >20 bytes would have been used
* as the workspace for all STRBUF
* routines.
STRWS  BSS  >20
* holds block size
BLOCKZ BSS  >2
* holds address of buffer
BUFADR BSS  >2

* Mask to set or reset the "used" bit.
FMASK  DATA >8000
 
*
* Reserve Space for string buffer
*
* R0 - buffer memory address
* R1 - buffer size (>4 to >7FFF valid)
* R2 - block size
*
* Output:
* R0 - >0000 if successful
*      >FFFF if error
*
STRALC DATA STRWS,STRALC+4
* Get routine parameters
       MOV  @0(13),R0
       MOV  @2(13),R1
       MOV  @4(13),@BLOCKZ
	   MOV  R0,@BUFADR
* Return error if buffer size is less
* than or equal to 4
       CI   R1,4
	   JLE  ALC0
* Return error if buffer size is greater
* than or equal to >8000
       CI   R1,>8000
	   JL   ALC1
ALC0   SETO @0(13)
	   RTWP
* Record address of end of buffer.
ALC1   MOV  R0,R2
       A    R1,R2
	   MOV  R2,*R0+
* Record empty chunk covering whole
* space.
       DECT R1
       MOV  R1,*R0
* Report success.
       CLR  @0(13)   
       RTWP
 
*
* Copy a string from the buffer to
* another location where it can be
* manipulated.
*
* R0 - string address within buffer.
* R1 - address presumably outside the
*      buffer
*
* The calling code is responsile for
* ensuring that there is sufficient
* space for the copy.
*
* The first byte in the destination
* will be the string length.
STRGET DATA STRWS,STRSET+4
       RTWP
 
*
* Put a new string in the buffer
*
* Input:
* R0 - string address outside of buffer
* Output:
* R0 - contains the new string address
*    - >FFFF implies an error
STRSET DATA STRWS,STRSET+4
* Get routine parameters
       MOV  *R13,R0
* Find space requirement
       BL   @CALCSP
* R2 now contains the required number
* of bytes.
* Find a free chunk of that size or 
* greater.
       MOV  @BUFADR,R3
* Store the end of the buffer.
	   MOV  *R3,R1
* Store the address of first chunk.	   
	   INCT R3
SET1   MOV  *R3,R4
	   CZC  @FMASK,R4
	   JEQ  SET2
       SZC  @FMASK,R4
SET3   A    R4,R3
       C    R3,R1   
	   JL   SET1
* We passed out of the buffer.
* Report an error in caller's R0.
	   SETO *R13
	   RTWP
* Chunk is free, but is it large enough?
* First try to merge other free chunks.
SET2   BL   @TRYMRG
* If required space is still larger than
* the size of merged chunk, continue
* loop.
       C    R2,R4
       JH   SET3
* This chunk at R3 is large enough.
* Save a copy of its address.
       MOV  R3,R1
* Mark the chunk as used
	   MOV  R2,*R3
       SOC  @FMASK,*R3
* If the chunk is large enough to split,
* do so.	   
	   S    R2,R4
	   JEQ  SET4
	   A    R2,R3
	   MOV  R4,*R3
* Copy string
* R1 contains the address of the 
* chunk, but don't overcopy the header.
SET4   INCT R1
       MOV  R1,R3
* Copy the number of characters in the
* string plus the length byte.
       MOVB *R0,R2
	   SRA  R2,8
       INC  R2
* Copy	   
SET5   MOVB *R0,*R3
	   INC  R0
	   INC  R3
	   DEC  R2
	   JNE  SET5
* R1 now contains the address of the 
* string. Put address in caller's R0.
	   MOV  R1,*R13
       RTWP
 
*
* Replace an existing string in the
* buffer. This will involve an algorithm
* that reserves more space if the new
* string is larger than the old. It will
* move the string to a new location if
* necessary to create enough room.
*
* Input:
* R0 - string address outside of buffer
* R1 - current address inside of buffer
* Output:
* R0 - contains the new string address
STREDT DATA STRWS,STREDT+4
       RTWP
 
*
* Remove an existing string from the
* buffer and mark the space as free.
*
* Input:
* R0 - string address inside of buffer
STRDLT DATA STRWS,STRDLT+4
* Get routine parameters
       MOV  *R13,R0
* The block to free is located two bytes
* before the string address.
       DECT R0
* Mark the block free
       SZC  @FMASK,*R0
* Merge this newly freed chunk with 
* the following chunk if it is free.
       MOV  R0,R3
	   BL   @TRYMRG
       RTWP

*
* Calc Space Requirements
* 
* Input: 
* R0 - byte at R0 should contain string
*      length
*
* Output:
* R0 - (unchanged)
* R1 - zero
* R2 - The required number of bytes
CALCSP MOVB *R0,R2
	   SRL  R2,8
* R2 now contains the number of 
* characters in string.
*
* Add two bytes for chunk header.
* Add one byte for the the string-
* length byte.
* Subtract one byte so we can 
* round up when we divide
       INCT R2
* Divide by the block size
       CLR  R1
	   DIV  @BLOCKZ,R1
	   INC  R1
* R1 now contains the required number
* of blocks in the chunk.
* Multiply by the block size
* to calculate the total number of bytes
       MPY  @BLOCKZ,R1
* R2 now contains the required number of
* blocks
       RT
	   
*
* Try Merge Free Space
*
* Input:
* R3 - Address of a free chunk
*
* Output:
* R1 - address of end of buffer
* R3 - (unchanged)
* R4 - new size of chunk
* R5 - next full chunk
TRYMRG
* Store the address of first chunk.
	   MOV  R3,R5
* Get end of buffer
       MOV  @BUFADR,R1
       MOV  *R1,R1	   
* Initially add 0 to R5's contents so we
* can ensure that the first chunk is
* really free.
       CLR  R4
* Each header contains an offset to the
* next block. Find the some of the
* offsets of consecutive free blocks.
TMRG1  A    R4,R5
       C    R5,R1
	   JHE  TMGR2
       MOV  *R5,R4
       CZC  @FMASK,R4
	   JEQ  TMRG1
* Calculate new offset
TMGR2  MOV  R5,R4
	   S    R3,R4
	   JEQ  TMRG3
* If new offset is greater than 0, but 
* it in header of first chunk.
       MOV  R4,*R3
TMRG3  RT
	   END