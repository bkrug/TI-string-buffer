       DEF  RUNTST
       REF  BUFINT,BUFCPY,BUFALC,BUFREE
       REF  MAKETX,PRINTL,OPENF,CLOSEF
       
* Run all tests
RUNTST BLWP @OPENF
       BL   @WRTST
       BL   @BADDTA
       BL   @TINT1
       BL   @BADDTA
       BL   @TINT2
       BL   @BADDTA
       BL   @TINT3
       BL   @BADDTA
       BL   @TINT4
       BL   @BADDTA
       BL   @TALC1
       BL   @BADDTA
       BL   @TALC2
       BL   @BADDTA
       BL   @TALC3
       BL   @BADDTA
       BL   @TFRE1
       BL   @BADDTA
       BL   @TFRE2
       BL   @BADDTA
       BL   @TEDT1
       BL   @BADDTA
       BL   @TEDT2
       BL   @BADDTA
       BL   @TEDT3
       BL   @BADDTA
       BL   @TEDT4
       BL   @BADDTA
       BL   @TEDT5
       BL   @BADDTA
       BL   @TGET1
       BL   @BADDTA
       BL   @TGET2
       BL   @WREND
       BLWP @CLOSEF
LOOP   JMP  LOOP
 
SPACE  BSS  >1000
SPEND
 
* Write something
WRTST  LI   R0,STARTM
       LI   R1,ENDM-STARTM
       BLWP @PRINTL
       RT
 
* Finished testing
WREND  LI   R0,ENDM
       LI   R1,ENDME-ENDM
       BLWP @PRINTL
       RT

STARTM TEXT 'Testing'
ENDM   TEXT 'Done'
ENDME  EVEN
       
*
* Place nonsense data in SPACE
*
BADDTA LI   R0,SPACE
       LI   R1,SPEND
       LI   R2,>E6C7
BADDT2 MOV  R2,*R0+
       C    R0,R1
       JNE  BADDT2
       RT
 
*
* Allocate >1000 bytes of space with >20
* byte blocks.
* Expect the first word to contain the
* header for one empty chunk covering
* the entire buffer.
TINT1  LI   R0,SPACE
       LI   R1,>1000
       BLWP @BUFINT
* Test success flag
       MOV  R0,R0
       JNE  FINT1A
* Test first chunk shoul have highest
* bit reset.
* Remaining 15-bits will contain offset
* of >1000.
       LI   R0,SPACE
       LI   R1,>1000
       C    *R0,R1
       JNE  FINT1C
       RT
FINT1A LI   R0,FINT1P
       LI   R1,FINT1Q-FINT1P
       BLWP @PRINTL
       RT
FINT1C MOV  *R0,R0
       LI   R1,FINT1S
       BLWP @MAKETX
       LI   R0,FINT1Q
       LI   R1,FINT1T-FINT1Q
       BLWP @PRINTL
       RT
FINT1P TEXT 'TINT1 failed. '
       TEXT 'BUFINT reports failure.'
FINT1Q TEXT 'TINT1 expected a free chunck '
       TEXT 'with 1000 bytes but found '
FINT1S TEXT '.... instead'
FINT1T EVEN
 
*
* Allocate >8000 bytes of space with
* >40 byte blocks.
* Expect the allocation to fail because
* >8000 is too big.
TINT2  LI   R0,SPACE
       LI   R1,>8000
       BLWP @BUFINT
* Test success flag
       MOV  R0,R0
       JEQ  FINT2
       RT
FINT2  LI   R0,FINT2M
       LI   R1,FINT2N-FINT2M
       BLWP @PRINTL
       RT
FINT2M TEXT 'TINT2 failed. '
       TEXT 'Expected allocation to fail '
       TEXT 'because space too big.'
FINT2N EVEN

*
* Allocate >0003 bytes of space.
* Expect the allocation to fail because
* >0003 is too small.
TINT3  LI   R0,SPACE
       LI   R1,>3
       BLWP @BUFINT
* Test success flag
       MOV  R0,R0
       JEQ  FINT3
       RT
FINT3  LI   R0,FINT3M
       LI   R1,FINT3N-FINT3M
       BLWP @PRINTL
       RT
FINT3M TEXT 'TINT3 failed. '
       TEXT 'Expected allocation to fail '
       TEXT 'because space too s.'
FINT3N EVEN

*
* Allocate >0013 bytes of space.
* Expect the allocation to fail because
* space must be even.
TINT4  LI   R0,SPACE
       LI   R1,>13
       BLWP @BUFINT
* Test success flag
       MOV  R0,R0
       JEQ  FINT4
       RT
FINT4  LI   R0,FINT4M
       LI   R1,FINT4N-FINT4M
       BLWP @PRINTL
       RT
FINT4M TEXT 'TINT4 failed. '
       TEXT 'Expected allocation to fail '
       TEXT 'because size must be even.'
FINT4N EVEN
 
*
* Reserve space at a new location in the
* buffer.
* First stream of 14 bytes should take
* up a 16 byte chunk (2 header bytes).
* Second string of 15 bytes should take
* up a 18 byte chunk (2 header bytes
* plus empty space).
* Expect a new free chunk at the end of
* the full chunks.
TALC1  LI   R0,SPACE
       LI   R1,>1000
       BLWP @BUFINT
       LI   R0,14
       BLWP @BUFALC
       MOV  R0,R3
       LI   R0,15
       BLWP @BUFALC
* Test first memory address
       LI   R2,SPACE+2
       C    R2,R3
       JNE  FALC1A
* Test second memory address
* First chunk took 16 bytes,
* then there is a 2-byte header.
       LI   R2,SPACE+16+2
       C    R2,R0
       JNE  FALC1B
* Test first chunk header
* Filled with next chunk >10 bytes later
       LI   R2,>8010
       DECT R3
       C    R2,*R3
       JNE  FALC1C
* Test second chunk
* Filled with next chunk >12 bytes later
       LI   R2,>8012
       DECT R0
       C    R2,*R0
       JNE  FALC1D
* Test free chunk
       LI   R0,SPACE+>10+>12
       LI   R2,>1000->10->12
       C    *R0,R2
       JNE  FALC1E
       RT
FALC1A MOV  R1,R0
       LI   R1,TERR1D
       BLWP @MAKETX
       MOV  R2,R0
       LI   R1,TERR1C
       BLWP @MAKETX
       LI   R0,TERR1A
       LI   R1,TERR1E-TERR1A
       BLWP @PRINTL
       RT
FALC1B MOV  R0,R0
       LI   R1,TERR1D
       BLWP @MAKETX
       MOV  R2,R0
       LI   R1,TERR1C
       BLWP @MAKETX
       MOV  @TERR1I,@TERR1B
       LI   R0,TERR1A
       LI   R1,TERR1E-TERR1A
       BLWP @PRINTL
       RT
FALC1C MOV  *R3,R0
       LI   R1,TERR1H
       BLWP @MAKETX
       MOV  R2,R0
       LI   R1,TERR1G
       BLWP @MAKETX
       LI   R0,TERR1E
       LI   R1,TERR1I-TERR1E
       BLWP @PRINTL
       RT
FALC1D MOV  *R1,R0
       LI   R1,TERR1H
       BLWP @MAKETX
       MOV  R2,R0
       LI   R1,TERR1G
       BLWP @MAKETX
       MOV  @TERR1I,@TERR1F
       LI   R0,TERR1E
       LI   R1,TERR1I-TERR1E
       BLWP @PRINTL
       RT       
FALC1E MOV  *R0,R0
       LI   R1,TERR1H
       BLWP @MAKETX
       MOV  R2,R0
       LI   R1,TERR1G
       BLWP @MAKETX
       MOVB @TERR1J,@TERR1F
       LI   R0,TERR1E
       LI   R1,TERR1I-TERR1E
       BLWP @PRINTL
       RT       
TERR1A TEXT 'TALC1 failed. '
TERR1B TEXT '1st chunk.        '
       TEXT 'Expected chunk to be assigned at'
       TEXT 'address '
TERR1C TEXT '.... but found address '
TERR1D TEXT '....'
*
TERR1E TEXT 'TALC1 failed. '
TERR1F TEXT '1st chunk.        '
       TEXT 'Expected chunk header '
TERR1G TEXT '.... but found '
TERR1H TEXT '....'
*
TERR1I TEXT '2nd'
TERR1J TEXT '3rd'
       EVEN
  
*
* Put two strings in the buffer. They
* should fill up the buffer completely.
* Put a third string in the buffer.
* You should get an error message.
TALC2  LI   R0,SPACE
* >F-bytes of data plus 2 header bytes
* rounded up to >12 bytes per string.
       LI   R1,>24
       BLWP @BUFINT
*
       LI   R0,>F
       BLWP @BUFALC
       CI   R0,>FFFF
       JEQ  FALC2A
*
       LI   R0,>F
       BLWP @BUFALC
       CI   R0,>FFFF
       JEQ  FALC2B
*
       LI   R0,>F
       BLWP @BUFALC
       CI   R0,>FFFF
       JNE  FALC2C
       RT
FALC2A LI   R0,SERR2A
       LI   R1,SERR2B-SERR2A
       BLWP @PRINTL
       RT
FALC2B LI   R0,SERR2B
       LI   R1,SERR2C-SERR2B
       BLWP @PRINTL
       RT
FALC2C LI   R0,SERR2C
       LI   R1,SERR2D-SERR2C
       BLWP @PRINTL
       RT
SERR2A TEXT 'TALC2. First ALC failed, expected success.'
SERR2B TEXT 'TALC2. Second ALC failed, expected success.'
SERR2C TEXT 'TALC2. Third ALC succeeded, expected failure.'
SERR2D

*
* Put two strings in the buffer. They
* should leave two empty bytes in the 
* buffer.
* Put a third string in the buffer.
* You should get an error message assigned
* it is too big to fit.
TALC3  LI   R0,SPACE
       LI   R1,>26
       BLWP @BUFINT
*
       LI   R0,>F
       BLWP @BUFALC
       CI   R0,>FFFF
       JEQ  FALC3A
*
       LI   R0,>F
       BLWP @BUFALC
       CI   R0,>FFFF
       JEQ  FALC3B
*
       LI   R0,>F
       BLWP @BUFALC
       CI   R0,>FFFF
       JNE  FALC3C
       RT
FALC3A LI   R0,SERR3A
       LI   R1,SERR3B-SERR3A
       BLWP @PRINTL
       RT
FALC3B LI   R0,SERR3B
       LI   R1,SERR3C-SERR3B
       BLWP @PRINTL
       RT
FALC3C LI   R0,SERR3C
       LI   R1,SERR3D-SERR3C
       BLWP @PRINTL
       RT
SERR3A TEXT 'TALC3. First ALC failed, expected success.'
SERR3B TEXT 'TALC3. Second ALC failed, expected success.'
SERR3C TEXT 'TALC3. Third ALC succeeded, expected failure.'
SERR3D

*
* Put four strings of that require one
* block of memory in the buffer. Then
* delete the first three. Then add a 
* new string that should require three
* blocks.
* Expect this new string to be inserted
* at the begining of the buffer.
TFRE1  LI   R0,SPACE
       LI   R1,>100
       BLWP @BUFINT
* Store short strings.
       LI   R0,>F
       BLWP @BUFALC
       MOV  R0,@DLTADR
       LI   R0,>F
       BLWP @BUFALC
       MOV  R0,@DLTADR+2
       LI   R0,>F
       BLWP @BUFALC
       MOV  R0,@DLTADR+4
       LI   R0,>F
       BLWP @BUFALC
       MOV  R0,@DLTADR+6
* Delete first three strings in reverse
* order.
       MOV  @DLTADR+4,R0
       BLWP @BUFREE
       MOV  @DLTADR+2,R0
       BLWP @BUFREE
       MOV  @DLTADR,R0
       BLWP @BUFREE       
* Store long string
       LI   R0,46
       BLWP @BUFALC
       LI   R2,SPACE+2
       C    R0,R2
       JNE  FFRE1
       RT
FFRE1  MOV  R0,R0
       LI   R1,DERR1C
       BLWP @MAKETX
       MOV  R2,R0
       LI   R1,DERR1B
       BLWP @MAKETX
       LI   R0,DERR1A
       LI   R1,DERR1D-DERR1A
       BLWP @PRINTL
       RT       
DLTADR BSS  >8
DERR1A TEXT 'TFRE1 failed. Expected long string at '
DERR1B TEXT '.... but it was at '
DERR1C TEXT '....'
DERR1D 

*
* Just like TFRE1 except that we delete
* the strings in the opposite order.
* That shouldn't change the results.
TFRE2  LI   R0,SPACE
       LI   R1,>100
       BLWP @BUFINT
* Store short strings.
       LI   R0,>F
       BLWP @BUFALC
       MOV  R0,@DLTADR
       LI   R0,>F
       BLWP @BUFALC
       MOV  R0,@DLTADR+2
       LI   R0,>F
       BLWP @BUFALC
       MOV  R0,@DLTADR+4
       LI   R0,>F
       BLWP @BUFALC
       MOV  R0,@DLTADR+6
* Delete first three strings in reverse
* order.
       MOV  @DLTADR,R0
       BLWP @BUFREE       
       MOV  @DLTADR+2,R0
       BLWP @BUFREE
       MOV  @DLTADR+4,R0
       BLWP @BUFREE
* Store long string
       LI   R0,46
       BLWP @BUFALC
       LI   R2,SPACE+2
       C    R0,R2
       JNE  FFRE2
       RT
FFRE2  MOV  R0,R0
       LI   R1,DERR2C
       BLWP @MAKETX
       MOV  R2,R0
       LI   R1,DERR2B
       BLWP @MAKETX
       LI   R0,DERR2A
       LI   R1,DERR2D-DERR2A
       BLWP @PRINTL
       RT       
DERR2A TEXT 'TFRE2 failed. Expected long string at '
DERR2B TEXT '.... but it was at '
DERR2C TEXT '....'
       EVEN
DERR2D

* 
* Allocate a small space, free it, and
* allocate another larger space. This
* string is the last string in the
* buffer.
TEDT1  LI   R0,SPACE
       LI   R1,>100
       BLWP @BUFINT
       LI   R0,15
       BLWP @BUFALC
       MOV  R0,R3
       BLWP @BUFREE
       LI   R0,60
       BLWP @BUFALC
       C    R0,R3
       JNE  FEDT1A
       DECT R0
       MOV  *R0,R1
       CI   R1,>803E
       JNE  FEDT1B
       LI   R0,SPACE+>3E
       MOV  *R0,R1
       CI   R1,>0100->3E
       JNE  FEDT1C
       RT
FEDT1A LI   R0,EERR1A
       LI   R1,EERR1B-EERR1A
       BLWP @PRINTL
       RT
FEDT1B MOV  R1,R0
       LI   R1,EERR1C-4
       BLWP @MAKETX
       LI   R0,EERR1B
       LI   R1,EERR1C-EERR1B
       BLWP @PRINTL
       RT
FEDT1C MOV  R1,R0
       LI   R1,EERR1D
       BLWP @MAKETX
       LI   R0,EERR1C
       LI   R1,EERR1E-EERR1C
       BLWP @PRINTL
       RT
TEDT1O
EERR1A TEXT 'TEDT1 failed. Location in buffer changed.'
EERR1B TEXT 'TEDT1 failed. Chunk header was wrong:'
       BSS  >4
EERR1C TEXT 'TEDT1 failed. Header of the next chunk '
       TEXT 'was wrong: '
EERR1D BSS  >4
EERR1E

* 
* Reserve some space, free it, and
* reserve space of the same size.
TEDT2  LI   R0,SPACE
       LI   R1,>100
       BLWP @BUFINT
       LI   R0,>F
       BLWP @BUFALC
* Save a copy of address.
       MOV  R0,R3
* Save a copy of old header value.
       MOV  R0,R4
       DECT R4
       MOV  *R4,R4
       BLWP @BUFREE
       LI   R0,>F
       BLWP @BUFALC
* Confirm address did not change
       C    R0,R3
       JNE  FEDT2A
* Confirm header did not change       
       DECT R0
       MOV  *R0,R0
       C    R0,R4
       JNE  FEDT2B
       RT
FEDT2A LI   R0,EERR2A
       LI   R1,EERR2B-EERR2A
       BLWP @PRINTL
       RT
FEDT2B LI   R1,EERR2C-4
       BLWP @MAKETX
       LI   R0,EERR2B
       LI   R1,EERR2C-EERR2B
       BLWP @PRINTL
       RT
EERR2A TEXT 'TEDT2 failed. Location in buffer changed.'
EERR2B TEXT 'TEDT2 failed. Chunk header changed: ....'
EERR2C

* 
* Reserve three small chunks.
* Free the middle chunk.
* Free the first chunk.
* Reserve enough space to fill part of the middle chunk.
TEDT3  LI   R0,SPACE
       LI   R1,>100
       BLWP @BUFINT
*
       LI   R0,>D
       BLWP @BUFALC
       MOV  R0,@ADRLST
       LI   R0,>D
       BLWP @BUFALC
       MOV  R0,@ADRLST+2
       LI   R0,>D
       BLWP @BUFALC
       MOV  R0,@ADRLST+4
*
       MOV  @ADRLST+2,R0
       BLWP @BUFREE
       MOV  @ADRLST,R0
       BLWP @BUFREE
*
       LI   R0,>19
       BLWP @BUFALC
* Location should not have changed
       C    R0,@ADRLST
       JNE  FEDT3A
* Chunk should be large enough for
* data plus 3 bytes.
       DECT R0
       MOV  *R0,R1
       CI   R1,>801C
       JNE  FEDT3B
* Next chunk should still be used
* and should still be 1 block
       AI   R0,>20
       MOV  *R0,R1
       CI   R1,>8010
       JNE  FEDT3C
       RT
FEDT3A LI   R0,EERR3A
       LI   R1,EERR3B-EERR3A
       BLWP @PRINTL
       RT
FEDT3B LI   R0,EERR3B
       LI   R1,EERR3C-EERR3B
       BLWP @PRINTL
       RT
FEDT3C LI   R0,EERR3C
       LI   R1,EERR3D-EERR3C
       BLWP @PRINTL
       RT
ADRLST BSS  >6
EERR3A TEXT 'TEDT3 failed. Location in buffer changed.'
EERR3B TEXT 'TEDT3 failed. Chunk header has wrong offset.'
EERR3C TEXT 'TEDT3 failed. Chunk header for the following'
       TEXT ' chunk should not have changed.'
EERR3D
       
* 
* Create four small memory chunks.
* Free the third memory chunk.
* Free the first memory chunk.
* Reserve a new memory chunk that won't
* fit in either empty chunk.
TEDT4  LI   R0,SPACE
       LI   R1,>100
       BLWP @BUFINT
*
       LI   R0,>D
       BLWP @BUFALC
       MOV  R0,@ADRLS4
       LI   R0,>D
       BLWP @BUFALC
       MOV  R0,@ADRLS4+2
       LI   R0,>D
       BLWP @BUFALC
       MOV  R0,@ADRLS4+4
       LI   R0,>D
       BLWP @BUFALC
       MOV  R0,@ADRLS4+6
*
       MOV  @ADRLS4+4,R0
       BLWP @BUFREE
       MOV  @ADRLS4,R0
       BLWP @BUFREE
*
       LI   R0,>17
       BLWP @BUFALC
* New address should be in the fifth block.
       CI   R0,SPACE+>42
       JNE  FEDT4A
* First block should now be free
       LI   R0,SPACE
       MOV  *R0,R0
       CI   R0,>0010
       JNE  FEDT4B
* Fifth block should be start of two
* block chunk.
       LI   R0,SPACE+>40
       MOV  *R0,R0
       CI   R0,>801A
       JNE  FEDT4C
* Seventh block should be start of 
* remaining free space
       LI   R0,SPACE+>5A
       MOV  *R0,R0
       CI   R0,>00A6
       JNE  FEDT4D
       RT
FEDT4A LI   R1,EERR1I
       BLWP @MAKETX
       LI   R0,EERR4A
       LI   R1,EERR4B-EERR4A
       BLWP @PRINTL
       RT
FEDT4B LI   R1,EERR4C
       BLWP @MAKETX
       LI   R0,EERR4B
       LI   R1,EERR4D-EERR4B
       BLWP @PRINTL
       RT
FEDT4C LI   R1,EERR4E
       BLWP @MAKETX
       LI   R0,EERR4D
       LI   R1,EERR4F-EERR4D
       BLWP @PRINTL
       RT
FEDT4D LI   R1,EERR4G
       BLWP @MAKETX
       LI   R0,EERR4F
       LI   R1,EERR4H-EERR4F
       BLWP @PRINTL
       RT
ADRLS4 BSS  >6
EERR4A TEXT 'TEDT4 failed. The string is in the '
       TEXT 'wrong address: '
EERR1I TEXT '....'
EERR4B TEXT 'TEDT4 failed. The first block '
       TEXT 'should now contain 0010 but contains '
EERR4C TEXT '....'
EERR4D TEXT 'TEDT4 failed. The fifth block '
       TEXT 'should now contain 8020 but contains '
EERR4E TEXT '....'
EERR4F TEXT 'TEDT4 failed. The seventh block '
       TEXT 'should now contain 00A0 but contains '
EERR4G TEXT '....'
EERR4H

*
* Create three chunks of equal size.
* Free the middle chunk.
* Free the first chunk.
* Allocate a new chunk slightly larger 
* than the freed up ones.
* There should be remaining empty space
* between the remaining two chunks.
TEDT5  LI   R0,SPACE
       LI   R1,>300
       BLWP @BUFINT
*
       LI   R0,>A
       BLWP @BUFALC
       LI   R0,>A
       BLWP @BUFALC
       MOV  R0,R2
       LI   R0,>A
       BLWP @BUFALC
*
       MOV  R2,R0
       BLWP @BUFREE
       LI   R0,SPACE+2
       BLWP @BUFREE
*
       LI   R0,>13
       BLWP @BUFALC
* Test address space
       CI   R0,SPACE+2
       JNE  FEDT5
* Test chunk header
       LI   R0,SPACE
       MOV  *R0,R0
       CI   R0,>8016
       JNE  FEDT5B
* Test chunk header of free space
       LI   R0,SPACE+>16
       MOV  *R0,R0
       CI   R0,>0002
       JNE  FEDT5C
       RT
FEDT5  LI   R1,EERR5B-4
       BLWP @MAKETX
       LI   R0,EERR5A
       LI   R1,EERR5B-EERR5A
       BLWP @PRINTL
       RT
FEDT5B LI   R1,EERR5C
       BLWP @MAKETX
       LI   R0,EERR5B
       LI   R1,EERR5D-EERR5B
       BLWP @PRINTL
       RT
FEDT5C LI   R1,EERR5E
       BLWP @MAKETX
       LI   R0,EERR5D
       LI   R1,EERR5F-EERR5D
       BLWP @PRINTL
       RT
EERR5A TEXT 'FEDT5 failed. '
       TEXT 'wrong address for string: ....'
EERR5B TEXT 'FEDT5 failed. '
       TEXT 'Expected header 8018 but saw '
EERR5C TEXT '....'
EERR5D TEXT 'FEDT5 failed. '
       TEXT 'Expected header 0008 but saw '
EERR5E TEXT '....'
EERR5F EVEN

*
* Create a string
* Copy it to a new location
TGET1
* R0 now contains address of string in
* buffer.
* Assign Copy-to address to R1.
       LI   R0,TGET1M
       LI   R1,TGET1O
       LI   R2,TGET1Q-TGET1M
       BLWP @BUFCPY
* The data in TGET1O is expected to
* match the pre-existing contents of
* TGET1N.
       LI   R0,TGET1N
TGET1A C    *R0+,*R1+
       JNE  FGET1
       CI   R0,TGET1O
       JL   TGET1A
       RT
FGET1  LI   R2,TGET1N
       S    R2,R0
       DECT R0
       LI   R1,GERR2
       BLWP @MAKETX
       LI   R0,GERR1
       LI   R1,GERR3-GERR1
       BLWP @PRINTL
       RT
TGET1M BYTE >12
       TEXT 'THIS IS SOME TEXT.'
TGET1Q BYTE 0
       DATA 0,0
TGET1N BYTE >12
       TEXT 'THIS IS SOME TEXT.'
       BYTE >7F
       DATA >F805,>E986
TGET1O DATA 0,0,0,0
       DATA 0,0,0,0
       DATA 0,>877F,>F805,>E986
TGET1P
GERR1  TEXT 'TGET1 failed. '
       TEXT 'The strings stopped matching '
       TEXT 'at '
GERR2  TEXT '....'
       TEXT ' bytes from the start.'
GERR3  EVEN

*
* Store and retrieve something other
* than string
TGET2  LI   R0,TGET2M
       LI   R1,TGET2O
       LI   R2,>8
       BLWP @BUFCPY
*
* The data in TGET2O is expected to
* match the pre-existing contents of
* TGET2N.
       LI   R0,TGET2N
TGET2A C    *R0+,*R1+
       JNE  FGET2
       CI   R0,TGET2O
       JL   TGET2A
       RT
FGET2  LI   R1,GERR2B
       LI   R2,TGET2N
FGET2A MOV  *R2,R0
       BLWP @MAKETX
       AI   R1,4
       INCT R2
       CI   R2,TGET2O
       JL   FGET2A
       LI   R1,GERR2C
FGET2B MOV  *R2,R0
       BLWP @MAKETX
       AI   R1,4
       INCT R2
       CI   R2,TGET2P
       JL   FGET2B
       LI   R0,GERR2A
       LI   R1,GERR2D-GERR2A
       BLWP @PRINTL
       RT
TGET2M DATA >47AF,>8410,>4719,>C381
TGET2N DATA >47AF,>8410,>4719,>C381
       DATA >FEFE,>FEFE
TGET2O DATA 0,0,0,0
       DATA >FEFE,>FEFE
TGET2P 
* >40 bytes of buffer space that *might*
* protect the output text from being 
* overwritten
       BSS  >40
GERR2A TEXT 'TGET2 failed. '
       TEXT 'Excpected '
GERR2B BSS  >18
       TEXT ' but found '
GERR2C BSS  >18
GERR2D 
       END