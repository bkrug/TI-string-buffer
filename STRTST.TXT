       DEF  RUNTST
       REF  VMBW
       REF  STRALC,STRGET,STRSET
       REF  MAKETX,PRINTL,OPENF,CLOSEF
       
SPACE  BSS  >3000
 
* Run all tests
RUNTST BLWP @OPENF
       BL   @WRTST
       BL   @BADDTA
       BL   @TALC1
       BL   @BADDTA
       BL   @TALC2
       BL   @BADDTA
       BL   @TALC3
       BL   @BADDTA
       BL   @TSET1
       BL   @BADDTA
       BL   @TSET2
       BL   @WREND
       BLWP @CLOSEF
LOOP   JMP  LOOP
 
* Write something
WRTST  LI   R0,STARTM
       LI   R1,ENDM-STARTM
       BLWP @PRINTL
       RT
 
* Finished testing
WREND  LI   R0,ENDM
       LI   R1,ENDME-ENDM
       BLWP @PRINTL
       RT

STARTM TEXT 'Testing'
ENDM   TEXT 'Done'
ENDME  EVEN
       
*
* Place nonsense data in SPACE
*
BADDTA LI   R0,SPACE
       LI   R1,SPACE+>3000
       LI   R2,>E6C7
BADDT2 MOV  R2,*R0+
       C    R0,R1
       JNE  BADDT2
       RT
 
*
* Allocate >1000 bytes of space with >20
* byte blocks.
* Expect the first two blocks to contain
* the address SPACE+>1000.
* The second and third byte represent an
* empty chunk covering >FFE bytes.
TALC1  LI   R0,SPACE
       LI   R1,>1000
       LI   R2,>20
       BLWP @STRALC
* Test success flag
	   MOV  R0,R0
	   JNE  FALC1A
* Test end of space address
	   LI   R0,SPACE
       A    R0,R1
       C    *R0,R1
       JNE  FALC1B
* Test first chunk
       INCT R0
       LI   R1,>FFE
	   C    *R0,R1
	   JNE  FALC1C
       RT
FALC1A LI   R0,FALC1P
       LI   R1,FALC1Q-FALC1P
	   BLWP @PRINTL
	   RT
FALC1B LI   R1,FALC1O
	   BLWP @MAKETX
	   LI   R0,SPACE+>1000
	   LI   R1,FALC1R
	   BLWP @MAKETX
       LI   R0,FALC1M
       LI   R1,FALC1N-FALC1M
       BLWP @PRINTL
       RT
FALC1C MOV  *R0,R0
       LI   R1,FALC1S
	   BLWP @MAKETX
	   LI   R0,FALC1Q
	   LI   R1,FALC1T-FALC1Q
	   BLWP @PRINTL
	   RT
FALC1M TEXT 'TALC1 failed. '
       TEXT 'Incorrect address of end '
       TEXT 'of the free space. '
	   TEXT 'Expected '
FALC1R BSS  >4
	   TEXT ' but saw '
FALC1O BSS  >4
FALC1N 
FALC1P TEXT 'TALC1 failed. '
       TEXT 'STRALC reports failure.'
FALC1Q TEXT 'TALC1 expected a free chunck '
       TEXT 'with 0FFE bytes but found '
FALC1S TEXT '.... instead'
FALC1T EVEN
 
*
* Allocate >8000 bytes of space with
* >40 byte blocks.
* Expect the allocation to fail because
* >8000 is too big.
TALC2  LI   R0,SPACE
       LI   R1,>8000
       LI   R2,>40
       BLWP @STRALC
* Test success flag
	   MOV  R0,R0
	   JEQ  FALC2
       RT
FALC2  LI   R0,FALC2M
       LI   R1,FALC2N-FALC2M
	   BLWP @PRINTL
	   RT
FALC2M TEXT 'TALC2 failed. '
       TEXT 'Expected allocation to fail '
       TEXT 'because space too big.'
FALC2N EVEN

*
* Allocate >0003 bytes of space with
* >40 byte blocks.
* Expect the allocation to fail because
* >0003 is too small.
TALC3  LI   R0,SPACE
       LI   R1,>3
       LI   R2,>40
       BLWP @STRALC
* Test success flag
	   MOV  R0,R0
	   JEQ  FALC3
       RT
FALC3  LI   R0,FALC3M
       LI   R1,FALC3N-FALC3M
	   BLWP @PRINTL
	   RT
FALC3M TEXT 'TALC3 failed. '
       TEXT 'Expected allocation to fail '
       TEXT 'because space too s.'
FALC3N EVEN
 
*
* Put strings at a new location in the
* buffer.
* Using a block size of 16 (>10) bytes.
* First string of 13 bytes should take
* up one memory block.
* Second string of 14 bytes should take
* up two memory blocks.
* Expect a new free chunk at the end of
* the full chunks.
TSET1  LI   R0,SPACE
       LI   R1,>1000
       LI   R2,>10
       BLWP @STRALC
	   LI   R0,SET1MA
       BLWP @STRSET
	   MOV  R0,R1
	   LI   R0,SET1MB
	   BLWP @STRSET
* Test first string address
       LI   R2,SPACE+4
	   C    R2,R1
	   JNE  FSET1A
* Test second string address
       LI   R2,SPACE+>14
	   C    R2,R0
	   JNE  FSET1B
* Test first chunk
       LI   R2,>8010
	   C    R2,*R1
	   JNE  FSET1C
* Test second chunk
       LI   R2,>8020
	   C    R2,*R0
	   JNE  FSET1D
* Test free chunk
* >1000 - >2 - >10 - >30 = >FCE
       AI   R0,>20
	   LI   R2,>0FCE
	   C    *R0,R2
	   JNE  FSET1E
       RT
FSET1A MOV  R1,R0
       LI   R1,TERR1D
	   BLWP @MAKETX
	   MOV  R2,R0
	   LI   R1,TERR1C
	   BLWP @MAKETX
       LI   R0,TERR1A
       LI   R1,TERR1E-TERR1A
	   BLWP @PRINTL
       RT
FSET1B MOV  R0,R0
       LI   R1,TERR1D
	   BLWP @MAKETX
	   MOV  R2,R0
	   LI   R1,TERR1C
	   BLWP @MAKETX
	   MOV  @TERR1I,@TERR1B
       LI   R0,TERR1A
       LI   R1,TERR1E-TERR1A
	   BLWP @PRINTL
       RT
FSET1C MOV  *R0,R0
       LI   R1,TERR1H
	   BLWP @MAKETX
	   MOV  R2,R0
	   LI   R1,TERR1G
	   BLWP @MAKETX
       LI   R0,TERR1E
       LI   R1,TERR1I-TERR1E
	   BLWP @PRINTL
       RT
FSET1D MOV  *R1,R0
       LI   R1,TERR1H
	   BLWP @MAKETX
	   MOV  R2,R0
	   LI   R1,TERR1G
	   BLWP @MAKETX
	   MOV  @TERR1I,@TERR1F
       LI   R0,TERR1E
       LI   R1,TERR1I-TERR1E
	   BLWP @PRINTL
       RT	   
FSET1E MOV  *R0,R0
       LI   R1,TERR1H
	   BLWP @MAKETX
	   MOV  R2,R0
	   LI   R1,TERR1G
	   BLWP @MAKETX
	   MOV  @TERR1J,@TERR1F
       LI   R0,TERR1E
       LI   R1,TERR1I-TERR1E
	   BLWP @PRINTL
       RT	   
SET1MA BYTE 13
       TEXT '13 byte strng'
SET1MB BYTE 14
       TEXT '14 byte string'
TERR1A TEXT 'TSET1 failed. '
TERR1B TEXT '1st chunk. '
       TEXT 'Expected string to be assigned '
       TEXT 'at address '
TERR1C TEXT '.... but found address '
TERR1D TEXT '....'
*
TERR1E TEXT 'TSET1 failed. '
TERR1F TEXT '1st chunk. '
       TEXT 'Expected chunk header '
TERR1G TEXT '.... but found '
TERR1H TEXT '....'
*
TERR1I TEXT '2nd'
TERR1J TEXT '3rd'
       EVEN
	   
*
* Put three strings of different sizes in
* new locations in the buffer.
* Should take up the last two memory
* blocks.
* Root node should be split, not full.
* Node A0 not split, not full.
* Node A1 split, not full.
* Node B2 not split, not full.
* Node B3 split, not full.
* Node C6 not split, full.
* Node C7 split, full.
* Node D14 not split, full.
* Node D15 not split, full.
TSET2  LI   R0,SPACE
       LI   R1,>100
       LI   R2,>10
       BLWP @STRALC
       LI   R0,MSET2A
       BLWP @STRSET
* Confirm string address 1.
       LI   R1,SPACE+>F0
       C    R0,R1
       JNE  FSET2A
       LI   R0,MSET2B
       BLWP @STRSET
* Confirm string address 2.
       LI   R1,SPACE+>C0
       C    R0,R1
       JNE  FSET2A
       LI   R0,MSET2C
       BLWP @STRSET
* Confirm string address 3.
       LI   R1,SPACE+>E0
       C    R0,R1
       JNE  FSET2B
* Confirm node values 
* Root node
       LI   R0,SPACE+>108
       LI   R1,>8000
       CB   *R0,R1
       JNE  FSET2B
* A-level nodes
       INC  R0
       LI   R1,>2000
       CB   *R0,R1
       JNE  FSET2B
* B-level nodes
       INC  R0
       LI   R1,>0200
       CB   *R0,R1
       JNE  FSET2B
* C-level nodes
       INCT R0          * skip first byte of level C
       LI   R1,>0700
       CB   *R0,R1
       JNE  FSET2B
* D-level nodes
       AI   R0,4        * skip first three bytes of level D
	   LI   R1,>0500
	   CB   *R0,R1
       JNE  FSET2B
       RT
FSET2A LI   R0,TERR2A
       LI   R1,TERR2B-TERR2A
	   BLWP @PRINTL
	   RT
FSET2B LI   R0,TERR2B
       LI   R1,TERR2C-TERR2B
       BLWP @PRINTL
       RT
TERR2A TEXT 'TSET2 string is at wrong address.'
TERR2B TEXT 'TSET2 node value is wrong.'
TERR2C
MSET2A BYTE 9
       TEXT 'Message 1'
MSET2B BYTE 29
       TEXT 'This should cover two blocks.'
MSET2C BYTE 6
       TEXT 'Mesg 2'
MSET2E EVEN 
       END