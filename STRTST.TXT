       DEF  RUNTST
       REF  VMBW
       REF  STRALC,STRGET,STRSET,STRDLT,STREDT
       REF  MAKETX,PRINTL,OPENF,CLOSEF
       
SPACE  BSS  >3000
 
* Run all tests
RUNTST BLWP @OPENF
       BL   @WRTST
       BL   @BADDTA
       BL   @TALC1
       BL   @BADDTA
       BL   @TALC2
       BL   @BADDTA
       BL   @TALC3
       BL   @BADDTA
       BL   @TSET1
       BL   @BADDTA
       BL   @TDLT1
       BL   @WREND
       BLWP @CLOSEF
LOOP   JMP  LOOP
 
* Write something
WRTST  LI   R0,STARTM
       LI   R1,ENDM-STARTM
       BLWP @PRINTL
       RT
 
* Finished testing
WREND  LI   R0,ENDM
       LI   R1,ENDME-ENDM
       BLWP @PRINTL
       RT

STARTM TEXT 'Testing'
ENDM   TEXT 'Done'
ENDME  EVEN
       
*
* Place nonsense data in SPACE
*
BADDTA LI   R0,SPACE
       LI   R1,SPACE+>3000
       LI   R2,>E6C7
BADDT2 MOV  R2,*R0+
       C    R0,R1
       JNE  BADDT2
       RT
 
*
* Allocate >1000 bytes of space with >20
* byte blocks.
* Expect the first two blocks to contain
* the address SPACE+>1000.
* The second and third byte represent an
* empty chunk covering >FFE bytes.
TALC1  LI   R0,SPACE
       LI   R1,>1000
       LI   R2,>20
       BLWP @STRALC
* Test success flag
	   MOV  R0,R0
	   JNE  FALC1A
* Test end of space address
	   LI   R0,SPACE
       A    R0,R1
       C    *R0,R1
       JNE  FALC1B
* Test first chunk
       INCT R0
       LI   R1,>FFE
	   C    *R0,R1
	   JNE  FALC1C
       RT
FALC1A LI   R0,FALC1P
       LI   R1,FALC1Q-FALC1P
	   BLWP @PRINTL
	   RT
FALC1B LI   R1,FALC1O
	   BLWP @MAKETX
	   LI   R0,SPACE+>1000
	   LI   R1,FALC1R
	   BLWP @MAKETX
       LI   R0,FALC1M
       LI   R1,FALC1N-FALC1M
       BLWP @PRINTL
       RT
FALC1C MOV  *R0,R0
       LI   R1,FALC1S
	   BLWP @MAKETX
	   LI   R0,FALC1Q
	   LI   R1,FALC1T-FALC1Q
	   BLWP @PRINTL
	   RT
FALC1M TEXT 'TALC1 failed. '
       TEXT 'Incorrect address of end '
       TEXT 'of the free space. '
	   TEXT 'Expected '
FALC1R BSS  >4
	   TEXT ' but saw '
FALC1O BSS  >4
FALC1N 
FALC1P TEXT 'TALC1 failed. '
       TEXT 'STRALC reports failure.'
FALC1Q TEXT 'TALC1 expected a free chunck '
       TEXT 'with 0FFE bytes but found '
FALC1S TEXT '.... instead'
FALC1T EVEN
 
*
* Allocate >8000 bytes of space with
* >40 byte blocks.
* Expect the allocation to fail because
* >8000 is too big.
TALC2  LI   R0,SPACE
       LI   R1,>8000
       LI   R2,>40
       BLWP @STRALC
* Test success flag
	   MOV  R0,R0
	   JEQ  FALC2
       RT
FALC2  LI   R0,FALC2M
       LI   R1,FALC2N-FALC2M
	   BLWP @PRINTL
	   RT
FALC2M TEXT 'TALC2 failed. '
       TEXT 'Expected allocation to fail '
       TEXT 'because space too big.'
FALC2N EVEN

*
* Allocate >0003 bytes of space with
* >40 byte blocks.
* Expect the allocation to fail because
* >0003 is too small.
TALC3  LI   R0,SPACE
       LI   R1,>3
       LI   R2,>40
       BLWP @STRALC
* Test success flag
	   MOV  R0,R0
	   JEQ  FALC3
       RT
FALC3  LI   R0,FALC3M
       LI   R1,FALC3N-FALC3M
	   BLWP @PRINTL
	   RT
FALC3M TEXT 'TALC3 failed. '
       TEXT 'Expected allocation to fail '
       TEXT 'because space too s.'
FALC3N EVEN
 
*
* Put strings at a new location in the
* buffer.
* Using a block size of 16 (>10) bytes.
* First string of 13 bytes should take
* up one memory block.
* Second string of 14 bytes should take
* up two memory blocks.
* Expect a new free chunk at the end of
* the full chunks.
TSET1  LI   R0,SPACE
       LI   R1,>1000
       LI   R2,>10
       BLWP @STRALC
	   LI   R0,SET1MA
       BLWP @STRSET
	   MOV  R0,R1
	   LI   R0,SET1MB
	   BLWP @STRSET
* Test first string address
       LI   R2,SPACE+4
	   C    R2,R1
	   JNE  FSET1A
* Test second string address
       LI   R2,SPACE+>14
	   C    R2,R0
	   JNE  FSET1B
* Test first chunk
       LI   R2,>8010
	   DECT R1
	   C    R2,*R1
	   JNE  FSET1C
* Test second chunk
       LI   R2,>8020
	   DECT R0
	   C    R2,*R0
	   JNE  FSET1D
* Test free chunk
* >1000 - >2 - >10 - >30 = >FCE
       AI   R0,>20
	   LI   R2,>0FCE
	   C    *R0,R2
	   JNE  FSET1E
       RT
FSET1A MOV  R1,R0
       LI   R1,TERR1D
	   BLWP @MAKETX
	   MOV  R2,R0
	   LI   R1,TERR1C
	   BLWP @MAKETX
       LI   R0,TERR1A
       LI   R1,TERR1E-TERR1A
	   BLWP @PRINTL
       RT
FSET1B MOV  R0,R0
       LI   R1,TERR1D
	   BLWP @MAKETX
	   MOV  R2,R0
	   LI   R1,TERR1C
	   BLWP @MAKETX
	   MOV  @TERR1I,@TERR1B
       LI   R0,TERR1A
       LI   R1,TERR1E-TERR1A
	   BLWP @PRINTL
       RT
FSET1C MOV  *R0,R0
       LI   R1,TERR1H
	   BLWP @MAKETX
	   MOV  R2,R0
	   LI   R1,TERR1G
	   BLWP @MAKETX
       LI   R0,TERR1E
       LI   R1,TERR1I-TERR1E
	   BLWP @PRINTL
       RT
FSET1D MOV  *R1,R0
       LI   R1,TERR1H
	   BLWP @MAKETX
	   MOV  R2,R0
	   LI   R1,TERR1G
	   BLWP @MAKETX
	   MOV  @TERR1I,@TERR1F
       LI   R0,TERR1E
       LI   R1,TERR1I-TERR1E
	   BLWP @PRINTL
       RT	   
FSET1E MOV  *R0,R0
       LI   R1,TERR1H
	   BLWP @MAKETX
	   MOV  R2,R0
	   LI   R1,TERR1G
	   BLWP @MAKETX
	   MOV  @TERR1J,@TERR1F
       LI   R0,TERR1E
       LI   R1,TERR1I-TERR1E
	   BLWP @PRINTL
       RT	   
SET1MA BYTE 13
       TEXT '13 byte strng'
SET1MB BYTE 14
       TEXT '14 byte string'
TERR1A TEXT 'TSET1 failed. '
TERR1B TEXT '1st chunk. '
       TEXT 'Expected string to be assigned '
       TEXT 'at address '
TERR1C TEXT '.... but found address '
TERR1D TEXT '....'
*
TERR1E TEXT 'TSET1 failed. '
TERR1F TEXT '1st chunk. '
       TEXT 'Expected chunk header '
TERR1G TEXT '.... but found '
TERR1H TEXT '....'
*
TERR1I TEXT '2nd'
TERR1J TEXT '3rd'
       EVEN
	   
*
* Put four strings of that require one
* block of memory in the buffer. Then
* delete the first three. Then add a 
* new string that should require three
* blocks.
* Expect this new string to be inserted
* at the begining of the buffer.
TDLT1  LI   R0,SPACE
       LI   R1,>100
       LI   R2,>10
       BLWP @STRALC
* Store short strings.
       LI   R0,DLT1MA
	   BLWP @STRSET
	   MOV  R0,@DLTADR
       LI   R0,DLT1MA
	   BLWP @STRSET
	   MOV  R0,@DLTADR+2
       LI   R0,DLT1MA
	   BLWP @STRSET
	   MOV  R0,@DLTADR+4
       LI   R0,DLT1MA
	   BLWP @STRSET
	   MOV  R0,@DLTADR+6
* Delete first three strings in reverse
* order.
       MOV  @DLTADR+4,R0
	   BLWP @STRDLT
       MOV  @DLTADR+2,R0
	   BLWP @STRDLT
       MOV  @DLTADR,R0
	   BLWP @STRDLT	   
* Store long string
       LI   R0,DLT1MB
	   BLWP @STRSET
	   LI   R2,SPACE+4
	   C    R0,R2
	   JNE  FDLT1
	   RT
FDLT1  MOV  R0,R0
       LI   R1,DERR1C
	   BLWP @MAKETX
       MOV  R2,R0
       LI   R1,DERR1B
       BLWP @MAKETX
	   LI   R0,DERR1A
	   LI   R1,DERR1D-DERR1A
       BLWP @PRINTL
       RT	   
DLTADR BSS  >8
DLT1MA BYTE 12
       TEXT 'short string'
DLT1MB BYTE 43
       TEXT 'a longer string that requires three blocks.'
DERR1A TEXT 'TDLT1 failed. Expected long string at '
DERR1B TEXT '.... but it was at '
DERR1C TEXT '....'
DERR1D 
       EVEN
       END