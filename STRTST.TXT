       DEF  RUNTST
       REF  VMBW
       REF  STRALC,STRGET,STRSET,STRDLT,STREDT
       REF  MAKETX,PRINTL,OPENF,CLOSEF
       
SPACE  BSS  >1000
SPEND
 
* Run all tests
RUNTST BLWP @OPENF
       BL   @WRTST
       BL   @BADDTA
       BL   @TALC1
       BL   @BADDTA
       BL   @TALC2
       BL   @BADDTA
       BL   @TALC3
       BL   @BADDTA
       BL   @TSET1
       BL   @BADDTA
       BL   @TDLT1
       BL   @BADDTA
       BL   @TDLT2
       BL   @BADDTA
       BL   @TEDT1
       BL   @BADDTA
       BL   @TEDT2
       BL   @BADDTA
       BL   @TEDT3
       BL   @BADDTA
       BL   @TEDT4
       BL   @BADDTA
       BL   @TEDT5
       BL   @WREND
       BLWP @CLOSEF
LOOP   JMP  LOOP
 
* Write something
WRTST  LI   R0,STARTM
       LI   R1,ENDM-STARTM
       BLWP @PRINTL
       RT
 
* Finished testing
WREND  LI   R0,ENDM
       LI   R1,ENDME-ENDM
       BLWP @PRINTL
       RT

STARTM TEXT 'Testing'
ENDM   TEXT 'Done'
ENDME  EVEN
       
*
* Place nonsense data in SPACE
*
BADDTA LI   R0,SPACE
       LI   R1,SPEND
       LI   R2,>E6C7
BADDT2 MOV  R2,*R0+
       C    R0,R1
       JNE  BADDT2
       RT
 
*
* Allocate >1000 bytes of space with >20
* byte blocks.
* Expect the first two blocks to contain
* the address SPACE+>1000.
* The second and third byte represent an
* empty chunk covering >FFE bytes.
TALC1  LI   R0,SPACE
       LI   R1,>1000
       LI   R2,>20
       BLWP @STRALC
* Test success flag
       MOV  R0,R0
       JNE  FALC1A
* Test end of space address
       LI   R0,SPACE
       A    R0,R1
       C    *R0,R1
       JNE  FALC1B
* Test first chunk
       INCT R0
       LI   R1,>FFE
       C    *R0,R1
       JNE  FALC1C
       RT
FALC1A LI   R0,FALC1P
       LI   R1,FALC1Q-FALC1P
       BLWP @PRINTL
       RT
FALC1B LI   R1,FALC1O
       BLWP @MAKETX
       LI   R0,SPACE+>1000
       LI   R1,FALC1R
       BLWP @MAKETX
       LI   R0,FALC1M
       LI   R1,FALC1N-FALC1M
       BLWP @PRINTL
       RT
FALC1C MOV  *R0,R0
       LI   R1,FALC1S
       BLWP @MAKETX
       LI   R0,FALC1Q
       LI   R1,FALC1T-FALC1Q
       BLWP @PRINTL
       RT
FALC1M TEXT 'TALC1 failed. '
       TEXT 'Incorrect address of end '
       TEXT 'of the free space. '
       TEXT 'Expected '
FALC1R BSS  >4
       TEXT ' but saw '
FALC1O BSS  >4
FALC1N 
FALC1P TEXT 'TALC1 failed. '
       TEXT 'STRALC reports failure.'
FALC1Q TEXT 'TALC1 expected a free chunck '
       TEXT 'with 0FFE bytes but found '
FALC1S TEXT '.... instead'
FALC1T EVEN
 
*
* Allocate >8000 bytes of space with
* >40 byte blocks.
* Expect the allocation to fail because
* >8000 is too big.
TALC2  LI   R0,SPACE
       LI   R1,>8000
       LI   R2,>40
       BLWP @STRALC
* Test success flag
       MOV  R0,R0
       JEQ  FALC2
       RT
FALC2  LI   R0,FALC2M
       LI   R1,FALC2N-FALC2M
       BLWP @PRINTL
       RT
FALC2M TEXT 'TALC2 failed. '
       TEXT 'Expected allocation to fail '
       TEXT 'because space too big.'
FALC2N EVEN

*
* Allocate >0003 bytes of space with
* >40 byte blocks.
* Expect the allocation to fail because
* >0003 is too small.
TALC3  LI   R0,SPACE
       LI   R1,>3
       LI   R2,>40
       BLWP @STRALC
* Test success flag
       MOV  R0,R0
       JEQ  FALC3
       RT
FALC3  LI   R0,FALC3M
       LI   R1,FALC3N-FALC3M
       BLWP @PRINTL
       RT
FALC3M TEXT 'TALC3 failed. '
       TEXT 'Expected allocation to fail '
       TEXT 'because space too s.'
FALC3N EVEN
 
*
* Put strings at a new location in the
* buffer.
* Using a block size of 16 (>10) bytes.
* First string of 13 bytes should take
* up one memory block.
* Second string of 14 bytes should take
* up two memory blocks.
* Expect a new free chunk at the end of
* the full chunks.
TSET1  LI   R0,SPACE
       LI   R1,>1000
       LI   R2,>10
       BLWP @STRALC
       LI   R0,SET1MA
       BLWP @STRSET
       MOV  R0,R1
       LI   R0,SET1MB
       BLWP @STRSET
* Test first string address
       LI   R2,SPACE+4
       C    R2,R1
       JNE  FSET1A
* Test second string address
       LI   R2,SPACE+>14
       C    R2,R0
       JNE  FSET1B
* Test first chunk
       LI   R2,>8010
       DECT R1
       C    R2,*R1
       JNE  FSET1C
* Test second chunk
       LI   R2,>8020
       DECT R0
       C    R2,*R0
       JNE  FSET1D
* Test free chunk
* >1000 - >2 - >10 - >30 = >FCE
       AI   R0,>20
       LI   R2,>0FCE
       C    *R0,R2
       JNE  FSET1E
       RT
FSET1A MOV  R1,R0
       LI   R1,TERR1D
       BLWP @MAKETX
       MOV  R2,R0
       LI   R1,TERR1C
       BLWP @MAKETX
       LI   R0,TERR1A
       LI   R1,TERR1E-TERR1A
       BLWP @PRINTL
       RT
FSET1B MOV  R0,R0
       LI   R1,TERR1D
       BLWP @MAKETX
       MOV  R2,R0
       LI   R1,TERR1C
       BLWP @MAKETX
       MOV  @TERR1I,@TERR1B
       LI   R0,TERR1A
       LI   R1,TERR1E-TERR1A
       BLWP @PRINTL
       RT
FSET1C MOV  *R0,R0
       LI   R1,TERR1H
       BLWP @MAKETX
       MOV  R2,R0
       LI   R1,TERR1G
       BLWP @MAKETX
       LI   R0,TERR1E
       LI   R1,TERR1I-TERR1E
       BLWP @PRINTL
       RT
FSET1D MOV  *R1,R0
       LI   R1,TERR1H
       BLWP @MAKETX
       MOV  R2,R0
       LI   R1,TERR1G
       BLWP @MAKETX
       MOV  @TERR1I,@TERR1F
       LI   R0,TERR1E
       LI   R1,TERR1I-TERR1E
       BLWP @PRINTL
       RT       
FSET1E MOV  *R0,R0
       LI   R1,TERR1H
       BLWP @MAKETX
       MOV  R2,R0
       LI   R1,TERR1G
       BLWP @MAKETX
       MOV  @TERR1J,@TERR1F
       LI   R0,TERR1E
       LI   R1,TERR1I-TERR1E
       BLWP @PRINTL
       RT       
SET1MA BYTE 13
       TEXT '13 byte strng'
SET1MB BYTE 14
       TEXT '14 byte string'
TERR1A TEXT 'TSET1 failed. '
TERR1B TEXT '1st chunk. '
       TEXT 'Expected string to be assigned '
       TEXT 'at address '
TERR1C TEXT '.... but found address '
TERR1D TEXT '....'
*
TERR1E TEXT 'TSET1 failed. '
TERR1F TEXT '1st chunk. '
       TEXT 'Expected chunk header '
TERR1G TEXT '.... but found '
TERR1H TEXT '....'
*
TERR1I TEXT '2nd'
TERR1J TEXT '3rd'
       EVEN
       
*
* Put four strings of that require one
* block of memory in the buffer. Then
* delete the first three. Then add a 
* new string that should require three
* blocks.
* Expect this new string to be inserted
* at the begining of the buffer.
TDLT1  LI   R0,SPACE
       LI   R1,>100
       LI   R2,>10
       BLWP @STRALC
* Store short strings.
       LI   R0,DLT1MA
       BLWP @STRSET
       MOV  R0,@DLTADR
       LI   R0,DLT1MA
       BLWP @STRSET
       MOV  R0,@DLTADR+2
       LI   R0,DLT1MA
       BLWP @STRSET
       MOV  R0,@DLTADR+4
       LI   R0,DLT1MA
       BLWP @STRSET
       MOV  R0,@DLTADR+6
* Delete first three strings in reverse
* order.
       MOV  @DLTADR+4,R0
       BLWP @STRDLT
       MOV  @DLTADR+2,R0
       BLWP @STRDLT
       MOV  @DLTADR,R0
       BLWP @STRDLT       
* Store long string
       LI   R0,DLT1MB
       BLWP @STRSET
       LI   R2,SPACE+4
       C    R0,R2
       JNE  FDLT1
       RT
FDLT1  MOV  R0,R0
       LI   R1,DERR1C
       BLWP @MAKETX
       MOV  R2,R0
       LI   R1,DERR1B
       BLWP @MAKETX
       LI   R0,DERR1A
       LI   R1,DERR1D-DERR1A
       BLWP @PRINTL
       RT       
DLTADR BSS  >8
DLT1MA BYTE 12
       TEXT 'short string'
DLT1MB BYTE 43
       TEXT 'a longer string that requires three blocks.'
DERR1A TEXT 'TDLT1 failed. Expected long string at '
DERR1B TEXT '.... but it was at '
DERR1C TEXT '....'
DERR1D 

*
* Just like TDLT1 except that we delete
* the strings in the opposite order.
* That shouldn't change the results.
TDLT2  LI   R0,SPACE
       LI   R1,>100
       LI   R2,>10
       BLWP @STRALC
* Store short strings.
       LI   R0,DLT1MA
       BLWP @STRSET
       MOV  R0,@DLTADR
       LI   R0,DLT1MA
       BLWP @STRSET
       MOV  R0,@DLTADR+2
       LI   R0,DLT1MA
       BLWP @STRSET
       MOV  R0,@DLTADR+4
       LI   R0,DLT1MA
       BLWP @STRSET
       MOV  R0,@DLTADR+6
* Delete first three strings in reverse
* order.
       MOV  @DLTADR,R0
       BLWP @STRDLT       
       MOV  @DLTADR+2,R0
       BLWP @STRDLT
       MOV  @DLTADR+4,R0
       BLWP @STRDLT
* Store long string
       LI   R0,DLT1MB
       BLWP @STRSET
       LI   R2,SPACE+4
       C    R0,R2
       JNE  FDLT2
       RT
FDLT2  MOV  R0,R0
       LI   R1,DERR2C
       BLWP @MAKETX
       MOV  R2,R0
       LI   R1,DERR2B
       BLWP @MAKETX
       LI   R0,DERR2A
       LI   R1,DERR2D-DERR2A
       BLWP @PRINTL
       RT       
DERR2A TEXT 'TDLT2 failed. Expected long string at '
DERR2B TEXT '.... but it was at '
DERR2C TEXT '....'
DERR2D 
       EVEN
       
* 
* Create a small string, and edit it
* into something larger. This string is
* the last string in the buffer.
TEDT1  LI   R0,SPACE
       LI   R1,>100
       LI   R2,>10
       BLWP @STRALC
       LI   R0,TEDT1M
       BLWP @STRSET
       MOV  R0,R2
       LI   R1,TEDT1N
       BLWP @STREDT
       C    R0,R2
       JNE  FEDT1A
       DECT R0
       MOV  *R0,R1
       CI   R1,>8040
       JNE  FEDT1B
       AI   R0,>40
       MOV  *R0,R1
       CI   R1,>00BE
       JNE  FEDT1C
       RT
FEDT1A LI   R0,EERR1A
       LI   R1,EERR1B-EERR1A
       BLWP @PRINTL
       RT
FEDT1B LI   R0,EERR1B
       LI   R1,EERR1C-EERR1B
       BLWP @PRINTL
       RT
FEDT1C MOV  R1,R0
       LI   R1,EERR1D
       BLWP @MAKETX
       LI   R0,EERR1C
       LI   R1,EERR1E-EERR1C
       BLWP @PRINTL
       RT
TEDT1M BYTE 12
       TEXT 'short string'
TEDT1N BYTE 57
       TEXT 'longer string requiring more '
       TEXT 'blocks than the previous one'
TEDT1O
EERR1A TEXT 'TEDT1 failed. Location in buffer changed.'
EERR1B TEXT 'TEDT1 failed. Chunk header was wrong.'
EERR1C TEXT 'TEDT1 failed. Header of the next chunk '
       TEXT 'was wrong: '
EERR1D BSS  >4
EERR1E

* 
* Create a small string, and edit it
* into something larger but requiring
* the same number of blocks.
TEDT2  LI   R0,SPACE
       LI   R1,>100
       LI   R2,>20
       BLWP @STRALC
       LI   R0,TEDT2M
       BLWP @STRSET
       MOV  R0,R2
       LI   R1,TEDT2N
       BLWP @STREDT
       C    R0,R2
       JNE  FEDT2A
       DECT R0
       MOV  *R0,R1
       CI   R1,>8020
       JNE  FEDT2B
       RT
FEDT2A LI   R0,EERR2A
       LI   R1,EERR2B-EERR2A
       BLWP @PRINTL
       RT
FEDT2B LI   R0,EERR2B
       LI   R1,EERR2C-EERR2B
       BLWP @PRINTL
       RT
TEDT2M BYTE 12
       TEXT 'short string'
TEDT2N BYTE 22
       TEXT 'longer string a little'
TEDT2O
EERR2A TEXT 'TEDT2 failed. Location in buffer changed.'
EERR2B TEXT 'TEDT2 failed. Chunk header changed.'
EERR2C

* 
* Create three small strings.
* Delete the middle string.
* Edit the first string to fill the
* space used by the middle string.
TEDT3  LI   R0,SPACE
       LI   R1,>100
       LI   R2,>10
       BLWP @STRALC
*
       LI   R0,TEDT3M
       BLWP @STRSET
       MOV  R0,@ADRLST
       LI   R0,TEDT3M
       BLWP @STRSET
       MOV  R0,@ADRLST+2
       LI   R0,TEDT3M
       BLWP @STRSET
       MOV  R0,@ADRLST+6
*
       MOV  @ADRLST+2,R0
       BLWP @STRDLT
*
       MOV  @ADRLST,R0
       LI   R1,TEDT3N
       BLWP @STREDT
* Location should not have changed
       C    R0,@ADRLST
       JNE  FEDT3A
* Chunk should use 2 blocks
       DECT R0
       MOV  *R0,R1
       CI   R1,>8020
       JNE  FEDT3B
* Next chunk should still be used
* and should still be 1 block
       AI   R0,>20
	   MOV  *R0,R1
	   CI   R1,>8010
	   JNE  FEDT3C
       RT
FEDT3A LI   R0,EERR3A
       LI   R1,EERR3B-EERR3A
       BLWP @PRINTL
       RT
FEDT3B LI   R0,EERR3B
       LI   R1,EERR3C-EERR3B
       BLWP @PRINTL
	   RT
FEDT3C LI   R0,EERR3C
       LI   R1,EERR3D-EERR3C
	   BLWP @PRINTL
       RT
ADRLST BSS  >6
TEDT3M BYTE 12
       TEXT 'short string'
TEDT3N BYTE 22
       TEXT 'longer string a little'
TEDT3O
EERR3A TEXT 'TEDT3 failed. Location in buffer changed.'
EERR3B TEXT 'TEDT3 failed. Chunk header has wrong offset.'
EERR3C TEXT 'TEDT3 failed. Chunk header for the following'
       TEXT ' chunk should not have changed.'
EERR3D
	   
* 
* Create four small strings.
* Delete the third string.
* Edit the first string in a way that
* fources the string to be moved to
* after the fourth string.
TEDT4  LI   R0,SPACE
       LI   R1,>100
       LI   R2,>10
       BLWP @STRALC
*
       LI   R0,TEDT4M
       BLWP @STRSET
       MOV  R0,@ADRLS4
       LI   R0,TEDT4M
       BLWP @STRSET
       MOV  R0,@ADRLS4+2
       LI   R0,TEDT4M
       BLWP @STRSET
       MOV  R0,@ADRLS4+4
       LI   R0,TEDT4M
       BLWP @STRSET
       MOV  R0,@ADRLS4+6
*
       MOV  @ADRLS4+4,R0
	   BLWP @STRDLT
*
       MOV  @ADRLS4,R0
	   LI   R1,TEDT4N
	   BLWP @STREDT
* New address should be in the fifth block.
       CI   R0,SPACE+>44
	   JNE  FEDT4A
* First block should now be free
       LI   R0,SPACE+>2
	   MOV  *R0,R0
       CI   R0,>0010
	   JNE  FEDT4B
* Fifth block should be start of two
* block chunk.
       LI   R0,SPACE+>42
       MOV  *R0,R0
       CI   R0,>8020
	   JNE  FEDT4C
* Seventh block should be start of 
* remaining free space
       LI   R0,SPACE+>62
	   MOV  *R0,R0
	   CI   R0,>009E
	   JNE  FEDT4D
	   RT
FEDT4A LI   R1,EERR1I
       BLWP @MAKETX
       LI   R0,EERR4A
       LI   R1,EERR4B-EERR4A
	   BLWP @PRINTL
	   RT
FEDT4B LI   R1,EERR4C
       BLWP @MAKETX
	   LI   R0,EERR4B
	   LI   R1,EERR4D-EERR4B
	   BLWP @PRINTL
	   RT
FEDT4C LI   R1,EERR4E
       BLWP @MAKETX
	   LI   R0,EERR4D
	   LI   R1,EERR4F-EERR4D
	   BLWP @PRINTL
	   RT
FEDT4D LI   R1,EERR4G
       BLWP @MAKETX
	   LI   R0,EERR4F
	   LI   R1,EERR4H-EERR4F
	   BLWP @PRINTL
	   RT
ADRLS4 BSS  >6
TEDT4M BYTE 12
       TEXT 'short string'
TEDT4N BYTE 22
       TEXT 'longer string a little'
TEDT4O
EERR4A TEXT 'TEDT4 failed. The string is in the '
       TEXT 'wrong address: '
EERR1I TEXT '....'
EERR4B TEXT 'TEDT4 failed. The first block '
       TEXT 'should now contain 0010 but contains '
EERR4C TEXT '....'
EERR4D TEXT 'TEDT4 failed. The fifth block '
       TEXT 'should now contain 8020 but contains '
EERR4E TEXT '....'
EERR4F TEXT 'TEDT4 failed. The seventh block '
       TEXT 'should now contain 009E but contains '
EERR4G TEXT '....'
EERR4H

*
* Create three strings, each using
* two blocks.
* Delete the middle string.
* Edit the first string to use three
* blocks.
* There should be one block empty
* between the remaining two strings.
TEDT5  LI   R0,SPACE
       LI   R1,>300
       LI   R2,>08
       BLWP @STRALC
*
       LI   R0,TEDT5M
       BLWP @STRSET
       LI   R0,TEDT5M
       BLWP @STRSET
       LI   R0,TEDT5M
       BLWP @STRSET
*
       LI   R0,SPACE+>14
	   BLWP @STRDLT
*
       LI   R0,SPACE+4
       LI   R1,TEDT5N
       BLWP @STREDT
*
       CI   R0,SPACE+4
	   JNE  FEDT5
*
	   LI   R0,SPACE+2
	   MOV  *R0,R0
	   CI   R0,>8018
	   JNE  FEDT5B
*
       LI   R0,SPACE+>1A
	   MOV  *R0,R0
	   CI   R0,>0008
	   JNE  FEDT5C
	   RT
FEDT5  LI   R0,EERR5A
       LI   R1,EERR5B-EERR5A
       BLWP @PRINTL
       RT
FEDT5B LI   R1,EERR5C
       BLWP @MAKETX
	   LI   R0,EERR5B
	   LI   R1,EERR5D-EERR5B
	   BLWP @PRINTL
	   RT
FEDT5C LI   R1,EERR5E
       BLWP @MAKETX
	   LI   R0,EERR5D
	   LI   R1,EERR5F-EERR5D
	   BLWP @PRINTL
	   RT
TEDT5M BYTE 9
       TEXT 'ABCDEFGHI'
TEDT5N BYTE 19
       TEXT '0123456789ABCDEF012'
TEDT5O
EERR5A TEXT 'FEDT5 failed. '
       TEXT 'wrong address for string.'
EERR5B TEXT 'FEDT5 failed. '
       TEXT 'Expected header 8018 but saw '
EERR5C TEXT '....'
EERR5D TEXT 'FEDT5 failed. '
       TEXT 'Expected header 0008 but saw '
EERR5E TEXT '....'
EERR5F
       END