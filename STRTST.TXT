       DEF  RUNTST
       REF  VMBW
       REF  STRALC,STRGET,STRSET
       REF  MAKETX,PRINTL,OPENF,CLOSEF
       
SPACE  BSS  >3000
 
* Run all tests
RUNTST BLWP @OPENF
       BL   @WRTST
       BL   @BADDTA
       BL   @TALC1
       BL   @BADDTA
       BL   @TALC2
       BL   @BADDTA
       BL   @TALC3
       BL   @BADDTA
       BL   @TSET1
       BL   @BADDTA
       BL   @TSET2
       BL   @WREND
       BLWP @CLOSEF
LOOP   JMP  LOOP
 
* Write something
WRTST  LI   R0,STARTM
       LI   R1,ENDM-STARTM
       BLWP @PRINTL
       RT
 
* Finished testing
WREND  LI   R0,ENDM
       LI   R1,ENDME-ENDM
       BLWP @PRINTL
       RT

STARTM TEXT 'Testing'
ENDM   TEXT 'Done'
ENDME  EVEN
       
*
* Place nonsense data in SPACE
*
BADDTA LI   R0,SPACE
       LI   R1,SPACE+>3000
       LI   R2,>E6C7
BADDT2 MOV  R2,*R0+
       C    R0,R1
       JNE  BADDT2
       RT
 
*
* Allocate >1000 bytes of space
* with >20 byte blocks.
* Expect root node size list to start at
* SPACE+>1000.
* The first entry should contain >07
* which implies an empty chunk whose
* length is 2^7 times the size of a
* block.
* 8 bytes later we expect a clump that
* is not split and not full.
TALC1  LI   R0,SPACE
       LI   R1,>1000
       LI   R2,>20
       BLWP @STRALC
       A    R0,R1
       LI   R0,>0700
       CB   R0,*R1
       JNE  FALC1
* Check root node
       CLR  R0
       AI   R1,>8
       CB   *R1,R0
       JNE  FALC1
       RT
FALC1  LI   R0,FALC1M
       LI   R1,FALC1N-FALC1M
       BLWP @PRINTL
       RT
FALC1M TEXT 'TALC1 failed. '
       TEXT 'Incorrect description '
       TEXT 'of free space.'
FALC1N EVEN
 
*
* Allocate >1000 bytes of space
* with >40 byte blocks.
* Expect root node size list to start at
* SPACE+>1000.
* The first entry should contain >06.
* 8 bytes later we expect a clump that
* is not split and not full.
TALC2  LI   R0,SPACE
       LI   R1,>1000
       LI   R2,>40
       BLWP @STRALC
       A    R0,R1
       LI   R0,>0600
       CB   R0,*R1
       JNE  FALC2
* Check root node
       AI   R1,>8
       MOVB *R1,*R1
       JNE  FALC2
       RT
FALC2  LI   R0,FALC2M
       LI   R1,FALC2N-FALC2M
       BLWP @PRINTL
       RT
FALC2M TEXT 'TALC2 failed. '
       TEXT 'Incorrect description '
       TEXT 'of free space.'
FALC2N EVEN
 
*
* Allocate >2000 bytes of space
* with >30 byte blocks.
* Expect root node size list to start at
* SPACE+>2000.
* Entry at index 0 should contain >07
* Entry at index 1 should contain >05
* Entry at index 2 should contain >03
* Entry at index 3 should contain >01
* 8 bytes later we expect a clump that
* is not split and not full.
TALC3  LI   R0,SPACE
       LI   R1,>2000
       LI   R2,>30
       BLWP @STRALC
* Entry at index 0
       LI   R1,SPACE+>2000
       LI   R0,>0700
       CB   R0,*R1
       JNE  FALC3
* Entry at index 1
       INC  R1
       LI   R0,>0500
       CB   R0,*R1
       JNE  FALC3
* Entry at index 2
       INC  R1
       LI   R0,>0300
       CB   R0,*R1
       JNE  FALC3
* Entry at index 3
       INC  R1
       LI   R0,>0100
       CB   R0,*R1
       JNE  FALC3
* Check first root node
       LI   R1,SPACE+>2008
       MOVB *R1,*R1
       JNE  FALC3
* Check second root node
       AI   R1,>41
       MOVB *R1,*R1
       JNE  FALC3
* Check third root node
       AI   R1,>11
       MOVB *R1,*R1
       JNE  FALC3
* Check fourth root node
       AI   R1,>05
       MOVB *R1,*R1
       JNE  FALC3
       RT
FALC3  LI   R0,FALC3M
       LI   R1,FALC3N-FALC3M
       BLWP @PRINTL
       RT
FALC3M TEXT 'TALC3 failed. '
       TEXT 'Free space should have '
       TEXT 'three entries.'
FALC3N EVEN

*
* Put a string at a new location in the
* buffer.
* Should take up the last two memory
* blocks.
* Root node should be split, not full.
* Node A1 not split, not full.
* Node A2 split, not full.
* Node B3 not split, not full.
* Node B4 split, not full.
* Node C7 not split, not full.
* Node C8 not split, full.
TSET1  LI   R0,SPACE
       LI   R1,>100
       LI   R2,>10
       BLWP @STRALC
       LI   R0,TSETA
       BLWP @STRSET
* Confirm string address.
       LI   R1,SPACE+>E0
       C    R0,R1
       JNE  FSET1A
* Confirm string values
       LI   R0,TSETA
       LI   R1,SPACE+>E0
TSET1B CB   R0,R1
       JNE  FSET1B
       INC  R0
       INC  R1
       CI   R0,TSETAE
       JL   TSET1B
* Confirm node values 
* Root node
       LI   R0,SPACE+>108
       LI   R1,>8000
       CB   *R0,R1
       JNE  FSET1C
* A-level nodes
       INC  R0
       LI   R1,>2000
       CB   *R0,R1
       JNE  FSET1C
* B-level nodes
       INC  R0
       LI   R1,>0200
       CB   *R0,R1
       JNE  FSET1C
* C-level nodes
       INC  R0
	   CLR  R1
       CB   *R0,R1
       JNE  FSET1C
       INC  R0
       LI   R1,>0100
       CB   *R0,R1
       JNE  FSET1C
       RT
FSET1A LI   R0,TERR1A
       LI   R1,TERR1B-TERR1A
	   BLWP @PRINTL
	   RT
FSET1B LI   R0,TERR1B
       LI   R1,TERR1C-TERR1B
       BLWP @PRINTL
       RT
FSET1C LI   R0,TERR1C
       LI   R1,TERR1D-TERR1C
       BLWP @PRINTL
       RT
TERR1A TEXT 'TSET1 string is at wrong address.'
TERR1B TEXT 'TSET1 string value is incorrect.'
TERR1C TEXT 'TSET1 node value is wrong.'
TERR1D
TSETA  BYTE >1A
       TEXT 'Some string over 16 bytes.'
TSETAE EVEN

*
* Put three strings of different sizes in
* new locations in the buffer.
* Should take up the last two memory
* blocks.
* Root node should be split, not full.
* Node A0 not split, not full.
* Node A1 split, not full.
* Node B2 not split, not full.
* Node B3 split, not full.
* Node C6 not split, full.
* Node C7 split, full.
* Node D14 not split, full.
* Node D15 not split, full.
TSET2  LI   R0,SPACE
       LI   R1,>100
       LI   R2,>10
       BLWP @STRALC
       LI   R0,MSET2A
       BLWP @STRSET
* Confirm string address 1.
       LI   R1,SPACE+>F0
       C    R0,R1
       JNE  FSET2A
       LI   R0,MSET2B
       BLWP @STRSET
* Confirm string address 2.
       LI   R1,SPACE+>C0
       C    R0,R1
       JNE  FSET2A
       LI   R0,MSET2C
       BLWP @STRSET
* Confirm string address 3.
       LI   R1,SPACE+>E0
       C    R0,R1
       JNE  FSET2B
* Confirm node values 
* Root node
       LI   R0,SPACE+>108
       LI   R1,>8000
       CB   *R0,R1
       JNE  FSET2B
* A-level nodes
       INC  R0
       LI   R1,>2000
       CB   *R0,R1
       JNE  FSET2B
* B-level nodes
       INC  R0
       LI   R1,>0200
       CB   *R0,R1
       JNE  FSET2B
* C-level nodes
       INCT R0          * skip first byte of level C
       LI   R1,>0700
       CB   *R0,R1
       JNE  FSET2B
* D-level nodes
       AI   R0,4        * skip first three bytes of level D
	   LI   R1,>0500
	   CB   *R0,R1
       JNE  FSET2B
       RT
FSET2A LI   R0,TERR2A
       LI   R1,TERR2B-TERR2A
	   BLWP @PRINTL
	   RT
FSET2B LI   R0,TERR2B
       LI   R1,TERR2C-TERR2B
       BLWP @PRINTL
       RT
TERR2A TEXT 'TSET2 string is at wrong address.'
TERR2B TEXT 'TSET2 node value is wrong.'
TERR2C
MSET2A BYTE 9
       TEXT 'Message 1'
MSET2B BYTE 29
       TEXT 'This should cover two blocks.'
MSET2C BYTE 6
       TEXT 'Mesg 2'
MSET2E EVEN 
       END